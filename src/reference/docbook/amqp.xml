<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="amqp"
    xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Using Spring AMQP</title>

  <para>In this chapter, we will explore the interfaces and classes that are the
  essential components for developing applications with Spring AMQP.</para>

  <section>
    <title>AMQP Abstractions</title>

    <para>Spring AMQP consists of a handful of modules, each represented by a
    JAR in the distribution. These modules are: spring-amqp, spring-rabbit and
    spring-erlang. The 'spring-amqp' module contains the
    <literal>org.springframework.amqp.core</literal> package. Within that
    package, you will find the classes that represent the core AMQP "model".
    Our intention is to provide generic abstractions that do not rely on any
    particular AMQP broker implementation or client library. End user code
    will be more portable across vendor implementations as it can be developed
    against the abstraction layer only. These abstractions are then used
    implemented by broker-specific modules, such as 'spring-rabbit'. For the
    1.0 release there is only a RabbitMQ implementation however the
    abstractions have been validated in .NET using Apache Qpid in addition to
    RabbitMQ. Since AMQP operates at the protocol level in principle the
    RabbitMQ client can be used with any broker that supports the same
    protocol version, but we do not test any other brokers at present.</para>

    <para>The overview here assumes that you are already familiar with the
    basics of the AMQP specification already. If you are not, then have a look
    at the resources listed in <xref linkend="resources" /></para>

    <sect2>
      <title>Message</title>

      <para>The 0-8 and 0-9-1 AMQP specifications do not define a Message
      class or interface. Instead, when performing an operation such as
      '<literal>
          <methodname>basicPublish</methodname>
        </literal>', the content is passed as a byte-array argument and
      additional properties are passed in as separate arguments. Spring AMQP
      defines a Message class as part of a more general AMQP domain model
      representation. The purpose of the Message class is to simply
      encapsulate the body and properties within a single instance so that the
      API can in turn be simpler. The Message class definition is quite
      straightforward.</para>

      <programlisting language="java"><![CDATA[public class Message {

    private final MessageProperties messageProperties;

    private final byte[] body;

    public Message(byte[] body, MessageProperties messageProperties) {
        this.body = body;
        this.messageProperties = messageProperties;
    }

    public byte[] getBody() {
        return this.body;
    }

    public MessageProperties getMessageProperties() {
        return this.messageProperties;
    }
}]]></programlisting>

      <para>The <interfacename>MessageProperties</interfacename> interface
      defines several common properties such as 'messageId', 'timestamp',
      'contentType', and several more. Those properties can also be extended
      with user-defined 'headers' by calling the <methodname>setHeader(String
      key, Object value)</methodname> method.</para>
    </sect2>

    <sect2>
      <title>Exchange</title>

      <para>The <interfacename>Exchange</interfacename> interface represents
      an AMQP Exchange, which is what a Message Producer sends to. Each
      Exchange within a virtual host of a broker will have a unique name as
      well as a few other properties:</para>

      <programlisting language="java"><![CDATA[public interface Exchange {

    String getName();

    String getExchangeType();

    boolean isDurable();

    boolean isAutoDelete();

    Map<String, Object> getArguments();

}]]></programlisting>

      <para>As you can see, an Exchange also has a 'type' represented by constants
      defined in <classname>ExchangeTypes</classname>. The basic types are:
      <literal>Direct</literal>, <literal>Topic</literal>,
      <literal>Fanout</literal>, and <literal>Headers</literal>.
      In the core package you will find
      implementations of the <interfacename>Exchange</interfacename> interface
      for each of those types. The behavior varies across these Exchange types
      in terms of how they handle bindings to Queues. For example, a Direct exchange allows
      for a Queue to be bound by a fixed routing key (often the Queue's name).
      A Topic exchange supports bindings with routing patterns that may
      include the '*' and '#' wildcards for 'exactly-one' and 'zero-or-more',
      respectively. The Fanout exchange publishes to all Queues that are bound
      to it without taking any routing key into consideration. For much more
      information about these and the other Exchange types, check out <xref
      linkend="resources" />.</para>

      <note>
        <para>The AMQP specification also requires that any broker provide a
        "default" Direct Exchange that has no name. All Queues that are
        declared will be bound to that default Exchange with their names as
        routing keys. You will learn more about the default Exchange's usage
        within Spring AMQP in <xref linkend="amqp-template" />.</para>
      </note>
    </sect2>

    <sect2>
      <title>Queue</title>

      <para>The <classname>Queue</classname> class represents the component
      from which a Message Consumer receives Messages. Like the various
      Exchange classes, our implementation is intended to be an abstract
      representation of this core AMQP type.</para>

      <programlisting language="java"><![CDATA[public class Queue  {

    private final String name;

    private volatile boolean durable;

    private volatile boolean exclusive;

    private volatile boolean autoDelete;

    private volatile Map<String, Object> arguments;

    /**
     * The queue is durable, non-exclusive and non auto-delete.
     *
     * @param name the name of the queue.
     */
    public Queue(String name) {
        this(name, true, false, false);
    }

    // Getters and Setters omitted for brevity

]]></programlisting>

      <para>Notice that the constructor takes the Queue name. Depending on the
      implementation, the admin template may provide methods for generating a
      uniquely named Queue. Such Queues can be useful as a "reply-to" address
      or other <emphasis>temporary</emphasis> situations. For that reason, the
      'exclusive' and 'autoDelete' properties of an auto-generated Queue would
      both be set to 'true'.</para>

      <note>See the section on queues in <xref linkend="broker-configuration" />
      for information about declaring queues using namespace support, including
      queue arguments.</note>
    </sect2>

    <sect2>
      <title>Binding</title>

      <para>Given that a producer sends to an Exchange and a consumer receives
      from a Queue, the bindings that connect Queues to Exchanges are critical
      for connecting those producers and consumers via messaging. In Spring
      AMQP, we define a <classname>Binding</classname> class to represent
      those connections. Let's review the basic options for binding Queues to
      Exchanges.</para>

      <para>You can bind a Queue to a DirectExchange with a fixed routing
      key.</para>

      <programlisting language="java"><![CDATA[new Binding(someQueue, someDirectExchange, "foo.bar")]]></programlisting>

      <para>You can bind a Queue to a TopicExchange with a routing
      pattern.</para>

      <programlisting language="java"><![CDATA[new Binding(someQueue, someTopicExchange, "foo.*")]]></programlisting>

      <para>You can bind a Queue to a FanoutExchange with no routing
      key.</para>

      <programlisting language="java"><![CDATA[new Binding(someQueue, someFanoutExchange)]]></programlisting>

      <para>We also provide a <classname>BindingBuilder</classname> to
      facilitate a "fluent API" style.</para>

      <programlisting language="java"><![CDATA[Binding b = BindingBuilder.bind(someQueue).to(someTopicExchange).with("foo.*");]]></programlisting>

      <note>
        <para>The BindingBuilder class is shown above for clarity, but this
        style works well when using a static import for the 'bind()'
        method.</para>
      </note>

      <para>By itself, an instance of the Binding class is just holding the
      data about a connection. In other words, it is not an "active"
      component. However, as you will see later in <xref
      linkend="broker-configuration" />, Binding instances can be used by the
      <interfacename>AmqpAdmin</interfacename> class to actually trigger the
      binding actions on the broker. Also, as you will see in that same
      section, the Binding instances can be defined using Spring's
      <literal>@Bean</literal>-style within <literal>@Configuration</literal>
      classes. There is also a convenient base class which further simplifies
      that approach for generating AMQP-related bean definitions and
      recognizes the Queues, Exchanges, and Bindings so that they will all be
      declared on the AMQP broker upon application startup.</para>
    </sect2>

    <para>The <interfacename>AmqpTemplate</interfacename> is also defined
    within the core package. As one of the main components involved in actual
    AMQP messaging, it is discussed in detail in its own section (see <xref
    linkend="amqp-template" />).</para>
  </section>

  <section id="connections">
    <title>Connection and Resource Management</title>

    <para>Whereas the AMQP model we described in the previous section is
    generic and applicable to all implementations, when we get into the
    management of resources, the details are specific to the broker
    implementation. Therefore, in this section, we will be focusing on code
    that exists only within our "spring-rabbit" module since at this point,
    RabbitMQ is the only supported implementation.</para>

    <para>The central component for managing a connection to the
    RabbitMQ broker is the
    <interfacename>ConnectionFactory</interfacename> interface.  The
    responsibility of a
    <interfacename>ConnectionFactory</interfacename> implementation is
    to provide an instance of
    <classname>org.springframework.amqp.rabbit.connection.Connection</classname>
    which is a wrapper for
    <classname>com.rabbitmq.client.Connection</classname>. The
    only concrete implementation we provide is
    <classname>CachingConnectionFactory</classname> which, by default, establishes a
    single connection proxy that can be shared by the application. Sharing
    of the connection is possible since the "unit of work" for
    messaging with AMQP is actually a "channel" (in some ways, this is
    similar to the relationship between a Connection and a Session in
    JMS). As you can imagine, the connection instance provides a
    <methodname>createChannel</methodname> method. The
    <classname>CachingConnectionFactory</classname> implementation
    supports caching of those channels, and it maintains separate
    caches for channels based on whether they are transactional or not.
    When creating an instance of <classname>CachingConnectionFactory</classname>,
    the 'hostname' can be provided via the constructor. The 'username' and
    'password' properties should be provided as well. If you would like to
    configure the size of the channel cache (the default is 1), you could
    call the <methodname>setChannelCacheSize()</methodname> method here as well.</para>
	<para>
		Starting with <emphasis>version 1.3</emphasis>, the <classname>CachingConnectionFactory</classname>
		can be configured to cache connections as well as just channels. In this case, each call to
		<code>createConnection()</code> creates a new connection (or retrieves an idle one from the cache).
		Closing a connection returns it to the cache (if the cache size has not been reached).
		Channels created on such connections are cached too. The use of separate connections might be
		useful in some environments, such as consuming from an HA cluster, in conjunction with a load balancer, to
		connect to different cluster members.
	</para>
	<important>
	  <para>
		When the cache mode is <code>CONNECTION</code>, automatic declaration of queues etc.
		(See <xref linkend="automatic-declaration" />) is NOT supported.
	  </para>
	  <para>
	    Also, at the time of writing, the <code>rabbitmq-client</code> library creates a fixed thread pool
	    for each connection (5 threads) by default. When using a large number of connections,
	    you should consider setting a custom <code>executor</code> on the
	    <classname>CachingConnectionFactory</classname>.
	    Then, the same executor will be used by all connections and its threads can be shared.
	    The executor's thread pool should be unbounded, or set appropriately for the expected utilization
	    (usually, at least one thread per connection). If multiple channels are created on each connection then
	    the pool size will affect the concurrency, so a variable (or simple cached) thread pool executor
	    would be most suitable.
	  </para>
	</important>

    <programlisting language="java"><![CDATA[CachingConnectionFactory connectionFactory = new CachingConnectionFactory("somehost");
connectionFactory.setUsername("guest");
connectionFactory.setPassword("guest");

Connection connection = connectionFactory.createConnection();]]></programlisting>

    <para>When using XML, the configuration might look like this:</para>

    <programlisting language="xml"><![CDATA[<bean id="connectionFactory"
      class="org.springframework.amqp.rabbit.connection.CachingConnectionFactory">
    <constructor-arg value="somehost"/>
    <property name="username" value="guest"/>
    <property name="password" value="guest"/>
</bean>]]></programlisting>

    <note> There is also a <classname>SingleConnectionFactory</classname>
    implementation which is only available in the unit test code of the framework.
    It is simpler than <classname>CachingConnectionFactory</classname> since it does
    not cache channels, but it is not intended for practical usage
    outside of simple tests due to its lack of performance and resilience.
    If you find a need to implement your own <classname>ConnectionFactory</classname>
    for some reason, the <classname>AbstractConnectionFactory</classname>
    base class may provide a nice starting point.</note>
    <para>
    A <classname>ConnectionFactory</classname> can
    be created quickly and conveniently using the rabbit namespace:
    </para>
    <programlisting language="xml"><![CDATA[<rabbit:connection-factory id="connectionFactory"/>]]></programlisting>
    <para>
    In most cases this
    will be preferable since the framework can choose the best
    defaults for you. The created instance will be a
    <classname>CachingConnectionFactory</classname>.

    Keep in mind that the default cache size for channels is 1.
    If you want more channels to be cached set a larger value via the
    'channelCacheSize' property. In XML it would look like this:
    </para>
    <programlisting language="xml"><![CDATA[<bean id="connectionFactory"
      class="org.springframework.amqp.rabbit.connection.CachingConnectionFactory">
    <constructor-arg value="somehost"/>
    <property name="username" value="guest"/>
    <property name="password" value="guest"/>
    <property name="channelCacheSize" value="25"/>
</bean>]]></programlisting>
    <para>
        And with the namespace you can just add the 'channel-cache-size' attribute:
    </para>
    <programlisting language="xml"><![CDATA[<rabbit:connection-factory
    id="connectionFactory" channel-cache-size="25"/>]]></programlisting>
    <para>
        The default cache mode is CHANNEL, but you can configure it to cache
        connections instead; in this case, we use <code>connection-cache-size</code>:
    </para>
    <programlisting language="xml"><![CDATA[<rabbit:connection-factory
    id="connectionFactory" cache-mode="CONNECTION" connection-cache-size="25"/>]]></programlisting>
    <para>
        Host and port attributes can be provided using the namespace
    </para>
    <programlisting language="xml"><![CDATA[<rabbit:connection-factory
    id="connectionFactory" host="somehost" port="5672"/>]]></programlisting>
    <para>
	Alternatively, if running in a clustered environment, use the addresses
	attribute.
	</para>
    <programlisting language="xml"><![CDATA[<rabbit:connection-factory
    id="connectionFactory" addresses="host1:5672,host2:5672"/>]]></programlisting>

    <section id="connection-factory">
      <title>Configuring the Underlying Client Connection Factory</title>
      <para>
        The <classname>CachingConnectionFactory</classname> uses an instance of the Rabbit
        client <classname>ConnectionFactory</classname>; a number of configuration properties
        are passed through (<code>host, port, userName, password, requestedHeartBeat,
        connectionTimeout</code> for
        example) when setting the equivalent property on the <classname>CachingConnectionFactory
        </classname>. To set other properties (<code>clientProperties</code> for example),
        define an instance of the rabbit factory and provide a reference to it using
        the appropriate constructor of the <classname>CachingConnectionFactory</classname>.
        When using the namespace as described above, provide a reference to the configured
        factory in the <code>connection-factory</code> attribute.
      </para>
      <programlisting language="xml"><![CDATA[<rabbit:connection-factory
      id="connectionFactory" connection-factory="rabbitConnectionFactory"/>]]></programlisting>
    </section>
    <section>
      <title>Configuring SSL</title>
      <para>
        Starting with <emphasis>version 1.4</emphasis>, a convenient <classname
        >RabbitConnectionFactoryBean</classname> is provided to enable convenient configuration
        of SSL properties on the underlying client connection factory, using dependency injection.
        Other setters simply delegate to the underlying
        factory. Previously you had to configure the SSL options programmatically.
      </para>
      <programlisting language="xml"><![CDATA[<rabbit:connection-factory id="rabbitConnectionFactory"
    connection-factory="clientConnectionFactory"
    host="${host}"
    port="${port}"
    virtual-host="${vhost}"
    username="${username}" password="${password}" />

<bean id="clientConnectionFactory"
        class="org.springframework.xd.dirt.integration.rabbit.RabbitConnectionFactoryBean">
    <property name="useSSL" value="true" />
    <property name="sslPropertiesLocation" value="file:/secrets/rabbitSSL.properties"/>
</bean>]]></programlisting>
      <para>
        Refer to the <ulink url="https://www.rabbitmq.com/ssl.html">RabbitMQ Documentation</ulink>
        for information about configuring SSL. Omit the <code>sslPropertiesLocation</code> property
        to connect over SSL without certificate validation. When using certificate validation, the property
        is a Spring <classname>Resource</classname> pointing to a properties file containing the following
        keys:
      </para>
      <programlisting>keyStore=file:/secret/keycert.p12
trustStore=file:/secret/trustStore
keyStore.passPhrase=secret
trustStore.passPhrase=secret</programlisting>
      <para>
        The <code>keyStore</code> and <code>truststore</code> are Spring <classname>Resources</classname>
        pointing to the stores. Typically this properties file will be secured by the operating system
        with the application having read access.
      </para>
	</section>
    <section id="routing-connection-factory">
      <title>Routing Connection Factory</title>
      <para>
		  Starting with <emphasis>version 1.3</emphasis>, the <classname>AbstractRoutingConnectionFactory</classname>
		  has been introduced. This provides a mechanism to configure mappings for several
		  <interfacename>ConnectionFactories</interfacename> and determine a target <interfacename>ConnectionFactory</interfacename>
		  by some <code>lookupKey</code> at runtime. Typically, the implementation checks a thread-bound context.
		  For convenience, Spring AMQP provides the <classname>SimpleRoutingConnectionFactory</classname>,
		  which gets the current thread-bound <code>lookupKey</code> from the <classname>SimpleResourceHolder</classname>:
		  <programlisting language="xml"><![CDATA[<bean id="connectionFactory"
      class="org.springframework.amqp.rabbit.connection.SimpleRoutingConnectionFactory">
	<property name="targetConnectionFactories">
		<map>
			<entry key="#{connectionFactory1.virtualHost}" ref="connectionFactory1"/>
			<entry key="#{connectionFactory2.virtualHost}" ref="connectionFactory2"/>
		</map>
	</property>
</bean>

<rabbit:template id="template" connection-factory="connectionFactory" />]]></programlisting>
		  <programlisting language="java"><![CDATA[public class MyService {

	@Autowired
	private RabbitTemplate rabbitTemplate;

	public void service(String vHost, String payload) {
		SimpleResourceHolder.bind(rabbitTemplate.getConnectionFactory(), vHost);
		rabbitTemplate.convertAndSend(payload);
		SimpleResourceHolder.unbind(rabbitTemplate.getConnectionFactory());
	}

}]]></programlisting>
		  It is important to unbind the resource after use.
		  For more information see the JavaDocs of <classname>AbstractRoutingConnectionFactory</classname>.
      </para>
    </section>
    <section id="cf-pub-conf-ret">
      <title>Publisher Confirms and Returns</title>
      <para>
        Confirmed and returned messages are supported by setting the
        <classname>CachingConnectionFactory</classname>'s <code>publisherConfirms</code>
        and <code>publisherReturns</code> properties to 'true' respectively.
      </para>
        When these options are set, <interfacename>Channel</interfacename>s created by
        the factory are wrapped in an <interfacename>PublisherCallbackChannel</interfacename>
        which is used to facilitate the callbacks. When such a channel is obtained, the
        client can register a <interfacename>PublisherCallbackChannel.Listener</interfacename>
        with the <interfacename>Channel</interfacename>. The
        <interfacename>PublisherCallbackChannel</interfacename> implementation contains logic
        to route a confirm/return to the appropriate listener.
      <para>
        These features are explained further in the following sections.
      </para>
		<tip>
			For some more background information, please see the following blog
			post by the RabbitMQ team titled
			<ulink url="http://www.rabbitmq.com/blog/2011/02/10/introducing-publisher-confirms/">Introducing Publisher Confirms</ulink>.
		</tip>
    </section>
  </section>

  <section id="amqp-template">
    <title>AmqpTemplate</title>

    <para>As with many other high-level abstractions provided by the Spring
    Framework and related projects, Spring AMQP provides a "template" that
    plays a central role. The interface that defines the main operations is
    called <interfacename>AmqpTemplate</interfacename>. Those operations cover
    the general behavior for sending and receiving Messages. In other words,
    they are not unique to any implementation, hence the "AMQP" in the name.
    On the other hand, there are implementations of that interface that are
    tied to implementations of the AMQP protocol. Unlike JMS, which is an
    interface-level API itself, AMQP is a wire-level protocol. The
    implementations of that protocol provide their own client libraries, so
    each implementation of the template interface will depend on a particular
    client library. Currently, there is only a single implementation:
    <classname>RabbitTemplate</classname>. In the examples that follow, you
    will often see usage of an "AmqpTemplate", but when you look at the
    configuration examples, or any code excerpts where the template is
    instantiated and/or setters are invoked, you will see the implementation
    type (e.g. "RabbitTemplate").</para>

    <para>As mentioned above, the <interfacename>AmqpTemplate</interfacename>
    interface defines all of the basic operations for sending and receiving
    Messages. We will explore Message sending and reception, respectively, in
    the two sections that follow.</para>

	<section id="template-retry">
		<title>Adding Retry Capabilities</title>
		<para>
			Starting with <emphasis>version 1.3</emphasis> you can now configure the
			<classname>RabbitTemplate</classname> to use a <classname>RetryTemplate</classname>
			to help with handling problems with broker connectivity. Refer to the
			<ulink url="https://github.com/spring-projects/spring-retry">spring-retry</ulink>
			project for complete information; the following is just one example that uses
			an exponential back off policy and the default <classname>SimpleRetryPolicy</classname>
			which will make three attempts before throwing the exception to the caller.
		</para>
		<para>
			Using the XML namespace:
		</para>
		<programlisting language="xml"><![CDATA[<rabbit:template id="template" connection-factory="connectionFactory" retry-template="retryTemplate"/>

<bean id="retryTemplate" class="org.springframework.retry.support.RetryTemplate">
	<property name="backOffPolicy">
		<bean class="org.springframework.retry.backoff.ExponentialBackOffPolicy">
			<property name="initialInterval" value="500" />
			<property name="multiplier" value="10.0" />
			<property name="maxInterval" value="10000" />
		</bean>
	</property>
</bean>]]></programlisting>
		<para>
			Using <classname>@Configuration</classname>:
		</para>
		<programlisting language="java"><![CDATA[@Bean
public AmqpTemplate rabbitTemplate();
		RabbitTemplate template = new RabbitTemplate(connectionFactory());
		RetryTemplate retryTemplate = new RetryTemplate();
		ExponentialBackOffPolicy backOffPolicy = new ExponentialBackOffPolicy();
		backOffPolicy.setInitialInterval(500);
		backOffPolicy.setMultiplier(10.0);
		backOffPolicy.setMaxInterval(10000);
		retryTemplate.setBackOffPolicy(backOffPolicy);
		template.setRetryTemplate(retryTemplate);
		return template;
}]]></programlisting>
	</section>
    <section id="template-confirms">
      <title>Publisher Confirms and Returns</title>
      <para>
        The <classname>RabbitTemplate</classname> implementation of <interfacename>AmqpTemplate</interfacename>
        supports Publisher Confirms and Returns.
      </para>
      <para>
        For returned messages, the template's
        <code>mandatory</code> property must be set to 'true', and it requires
        a <classname>CachingConnectionFactory</classname> that has its
        <code>publisherReturns</code> property set to true
        (see <xref linkend="cf-pub-conf-ret"/>).
        Returns are sent to
        to the client by it registering a <interfacename>RabbitTemplate.ReturnCallback</interfacename>
        by calling <code>setReturnCallback(ReturnCallback callback)</code>. The callback
        must implement this method:
      </para>
      <programlisting language="java"><![CDATA[void returnedMessage(Message message, int replyCode, String replyText,
          String exchange, String routingKey);]]></programlisting>
      <para>
        Only one <interfacename>ReturnCallback</interfacename> is supported by each
        <classname>RabbitTemplate</classname>.
      </para>
      <para>
        For Publisher Confirms (aka Publisher Acknowledgements), the template requires
        a <classname>CachingConnectionFactory</classname> that has its
        <code>publisherConfirms</code> property set to true.  Confirms are sent to
        to the client by it registering a <interfacename>RabbitTemplate.ConfirmCallback</interfacename>
        by calling <code>setConfirmCallback(ConfirmCallback callback)</code>. The callback
        must implement this method:
      </para>
      <important>
        Publisher Confirms only work when the channel is cached. Otherwise, the channel is closed after the
        publish operation so, by definition, cannot receive the confirmation. Be sure to set the
        connection factory's <code>channelCacheSize</code> to a large enough value so that the channel on which a
		message is published is returned to the cache instead of being closed.
      </important>
      <programlisting language="java"><![CDATA[void confirm(CorrelationData correlationData, boolean ack, String cause);]]></programlisting>
      <para>
        The <classname>CorrelationData</classname> is an object supplied by the client when sending the
        original message. This is described further in the next section. The <code>ack</code> is true for
        an <code>ack</code> and false for a <code>nack</code>. For <code>nack</code>s, the cause may
        contain a reason for the nack, if it is available when the <code>nack</code> is generated. An example
        is when sending a message to a non-existent exchange. In that case the broker closes the channel; the
        reason for the closure is included in the <code>cause</code>. <code>cause</code> was added in
        <emphasis>version 1.4</emphasis>.
      </para>
      <para>
        Only one <interfacename>ConfirmCallback</interfacename> is supported by a
        <classname>RabbitTemplate</classname>.
      </para>
    </section>
  </section>

  <section>
    <title>Sending messages</title>

    <para>When sending a Message, one can use any of the following
    methods:</para>

    <programlisting language="java"><![CDATA[void send(Message message) throws AmqpException;

void send(String routingKey, Message message) throws AmqpException;

void send(String exchange, String routingKey, Message message) throws AmqpException;]]></programlisting>

    <para>We can begin our discussion with the last method listed above since
    it is actually the most explicit. It allows an AMQP Exchange name to be
    provided at runtime along with a routing key. The last parameter is the
    callback that is responsible for actual creating of the Message instance.
    An example of using this method to send a Message might look this
    this:</para>

    <programlisting language="java"><![CDATA[amqpTemplate.send("marketData.topic", "quotes.nasdaq.FOO",
    new Message("12.34".getBytes(), someProperties));]]></programlisting>

    <para>The "exchange" property can be set on the template itself if you
    plan to use that template instance to send to the same exchange most or
    all of the time. In such cases, the second method listed above may be used
    instead. The following example is functionally equivalent to the previous
    one:</para>

    <programlisting language="java"><![CDATA[amqpTemplate.setExchange("marketData.topic");
amqpTemplate.send("quotes.nasdaq.FOO", new Message("12.34".getBytes(), someProperties));]]></programlisting>

    <para>If both the "exchange" and "routingKey" properties are set on the
    template, then the method accepting only the
    <interfacename>Message</interfacename> may be used:</para>

    <programlisting language="java"><![CDATA[amqpTemplate.setExchange("marketData.topic");
amqpTemplate.setRoutingKey("quotes.nasdaq.FOO");
amqpTemplate.send(new Message("12.34".getBytes(), someProperties));]]></programlisting>

    <para>A better way of thinking about the exchange and routing key
    properties is that the explicit method parameters will always override the
    template's default values. In fact, even if you do not explicitly set
    those properties on the template, there are always default values in
    place. In both cases, the default is an empty String, but that is actually
    a sensible default. As far as the routing key is concerned, it's not
    always necessary in the first place (e.g. a Fanout Exchange). Furthermore,
    a Queue may be bound to an Exchange with an empty String. Those are both
    legitimate scenarios for reliance on the default empty String value for
    the routing key property of the template. As far as the Exchange name is
    concerned, the empty String is quite commonly used because the AMQP
    specification defines the "default Exchange" as having no name. Since all
    Queues are automatically bound to that default Exchange (which is a Direct
    Exchange) using their name as the binding value, that second method above
    can be used for simple point-to-point Messaging to any Queue through the
    default Exchange. Simply provide the queue name as the "routingKey" -
    either by providing the method parameter at runtime:</para>

    <programlisting language="java"><![CDATA[RabbitTemplate template = new RabbitTemplate(); // using default no-name Exchange
template.send("queue.helloWorld", new Message("Hello World".getBytes(), someProperties));]]></programlisting>

    <para>Or, if you prefer to create a template that will be used for
    publishing primarily or exclusively to a single Queue, the following is
    perfectly reasonable:</para>

    <programlisting language="java"><![CDATA[RabbitTemplate template = new RabbitTemplate(); // using default no-name Exchange
template.setRoutingKey("queue.helloWorld"); // but we'll always send to this Queue
template.send(new Message("Hello World".getBytes(), someProperties));]]></programlisting>
	<section id="message-builder">
		<title>Message Builder API</title>
		<para>
			Starting with <emphasis>version 1.3</emphasis>, a message builder API is
			provided by the <classname>MessageBuilder</classname> and <classname>MessagePropertiesBuilder</classname>;
			they provides a convenient "fluent" means of creating a message or message properties:
		</para>
		<programlisting language="java"><![CDATA[Message message = MessageBuilder.withBody("foo".getBytes())
	.setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)
	.setMessageId("123")
	.setHeader("bar", "baz")
	.build();]]></programlisting>
		<para>
			or
		</para>
		<programlisting language="java"><![CDATA[MessageProperties props = MessagePropertiesBuilder.newInstance()
	.setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)
	.setMessageId("123")
	.setHeader("bar", "baz")
	.build();
Message message = MessageBuilder.withBody("foo".getBytes())
	.andProperties(props)
	.build();
]]></programlisting>
		<para>
			Each of the properties defined on the
			<ulink url="http://docs.spring.io/spring-amqp/docs/latest-ga/api/org/springframework/amqp/core/MessageProperties.html"
			>MessageProperies</ulink> can be set. Other  methods include <code>setHeader(String key, String value)</code>,
			<code>removeHeader(String key)</code>, <code>removeHeaders()</code>, and
			<code>copyProperties(MessageProperties properties)</code>. Each property setting method has a
			<code>set*IfAbsent()</code> variant. In the cases where a default initial value exists, the method is named
			<code>set*IfAbsentOrDefault()</code>.
		</para>
		<para>
			Five static methods are provided to create an initial message builder:
		</para>
		<programlisting language="java"><![CDATA[public static MessageBuilder withBody(byte[] body) ]]><co id="mb1" /><![CDATA[

public static MessageBuilder withClonedBody(byte[] body) ]]><co id="mb2" /><![CDATA[

public static MessageBuilder withBody(byte[] body, int from, int to) ]]><co id="mb3" /><![CDATA[

public static MessageBuilder fromMessage(Message message) ]]><co id="mb4" /><![CDATA[

public static MessageBuilder fromClonedMessage(Message message) ]]><co id="mb5" /></programlisting>
		<calloutlist>
			<callout arearefs="mb1">
				<para>
					The message created by the builder will have a body that is a direct reference to the argument.
				</para>
			</callout>
			<callout arearefs="mb2">
				<para>
					The message created by the builder will have a body that is a new array containing a copy of
					bytes in the argument.
				</para>
			</callout>
			<callout arearefs="mb3">
				<para>
					The message created by the builder will have a body that is a new array containing the range
					of bytes from the argument. See <code>Arrays.copyOfRange()</code> for more details.
				</para>
			</callout>
			<callout arearefs="mb4">
				<para>
					The message created by the builder will have a body that is a direct reference to the
					body of the argument.
					The argument's properties are copied to a new a <classname>MessageProperties</classname> object.
				</para>
			</callout>
			<callout arearefs="mb5">
				<para>
					The message created by the builder will have a body that is a new array containing a copy of
					the argument's body.
					The argument's properties are copied to a new a <classname>MessageProperties</classname> object.
				</para>
			</callout>
		</calloutlist>
		<para>
			Three static methods are provided to create an initial message properties builder:
		</para>
		<programlisting language="java"><![CDATA[public static MessagePropertiesBuilder newInstance() ]]><co id="mb101" /><![CDATA[

public static MessagePropertiesBuilder fromProperties(MessageProperties properties) ]]><co id="mb102" /><![CDATA[

public static MessagePropertiesBuilder fromClonedProperties(MessageProperties properties) ]]><co id="mb103" /></programlisting>
		<calloutlist>
			<callout arearefs="mb101">
				<para>
					A new message properties object is initialized with default values.
				</para>
			</callout>
			<callout arearefs="mb102">
				<para>
					The builder is initialized with, and <code>build()</code> will return, the provided properties
					object.
				</para>
			</callout>
			<callout arearefs="mb103">
				<para>
					The argument's properties are copied to a new a <classname>MessageProperties</classname> object.
				</para>
			</callout>
		</calloutlist>
	</section>
    <section>
      <title>Publisher Confirms</title>
      <para>
        With the <classname>RabbitTemplate</classname> implementation of <interfacename>AmqpTemplate</interfacename>,
        each of the <code>send()</code> methods has an overloaded version that takes an
        additional <interfacename>CorrelationData</interfacename> object. When publisher confirms
        are enabled, this object is returned in the callback described in
        <xref linkend="amqp-template"/>. This allows the sender to correlate
        a confirm (ack or nack) with the sent message.
      </para>
    </section>
    <section>
      <title>Publisher Returns</title>
      <para>
        When the template's <code>mandatory</code> property is 'true' returned messages are provided
        by the callback described in <xref linkend="amqp-template"/>.
      </para>
    </section>
  </section>

  <section id="receiving-messages">
    <title>Receiving messages</title>

    <para>Message reception is always a bit more complicated than sending. The
    reason is that there are two ways to receive a
    <classname>Message</classname>. The simpler option is to poll for a single
    <classname>Message</classname> at a time with a polling
    method call. The more complicated yet more common approach is to register
    a listener that will receive <classname>Messages</classname> on-demand,
    asynchronously. We will look at an example of each approach in the next
    two sub-sections.</para>

    <section>
      <title>Polling Consumer</title>

      <para>The <interfacename>AmqpTemplate</interfacename> itself can be used
      for polled Message reception. If no message is available, <code>null</code> is returned
      immediately; there is no blocking. There are two simple 'receive' methods
      available. As with the Exchange on the sending side, there is a method
      that requires a default queue property having been set directly on the template
      itself, and there is a method that accepts a queue parameter at
      runtime.</para>

      <programlisting language="java"><![CDATA[Message receive() throws AmqpException;

Message receive(String queueName) throws AmqpException;]]></programlisting>

      <para>Just like in the case of sending messages, the
      <classname>AmqpTemplate</classname> has some convenience methods for
      receiving POJOs instead of <classname>Message</classname> instances, and
      implementations will provide a way to customize the
      <classname>MessageConverter</classname> used to create the
      <classname>Object</classname> returned:</para>

      <para>
        <programlisting language="java"><![CDATA[Object receiveAndConvert() throws AmqpException;

Object receiveAndConvert(String queueName) throws AmqpException;]]></programlisting>
      </para>
		<para>Similar to <code>sendAndReceive</code> methods, beginning with
		  <emphasis>version 1.3</emphasis>, the <interfacename>AmqpTemplate</interfacename>
		  has several convenience <code>receiveAndReply</code> methods for synchronously
		  receiving, processing and replying to messages:
	  <programlisting language="java"><![CDATA[<R, S> boolean receiveAndReply(ReceiveAndReplyCallback<R, S> callback)
	   throws AmqpException;

<R, S> boolean receiveAndReply(String queueName, ReceiveAndReplyCallback<R, S> callback)
 	throws AmqpException;

<R, S> boolean receiveAndReply(ReceiveAndReplyCallback<R, S> callback,
	String replyExchange, String replyRoutingKey) throws AmqpException;

<R, S> boolean receiveAndReply(String queueName, ReceiveAndReplyCallback<R, S> callback,
	String replyExchange, String replyRoutingKey) throws AmqpException;

<R, S> boolean receiveAndReply(ReceiveAndReplyCallback<R, S> callback,
 	ReplyToAddressCallback<S> replyToAddressCallback) throws AmqpException;

<R, S> boolean receiveAndReply(String queueName, ReceiveAndReplyCallback<R, S> callback,
			ReplyToAddressCallback<S> replyToAddressCallback) throws AmqpException;]]></programlisting>
			The <interfacename>AmqpTemplate</interfacename> implementation takes care of the 'receive' and 'reply' phases.
			In most cases you should provide only an implementation of <interfacename>ReceiveAndReplyCallback</interfacename>
			to perform some business logic for the received message and build a reply object or message, if needed.
			Note, a <interfacename>ReceiveAndReplyCallback</interfacename> may return <code>null</code>. In this case
			no reply is sent and <code>receiveAndReply</code> works like the <code>receive</code> method. This allows
			the same queue to be used for a mixture of messages, some of which may not need a reply.
		</para>
		<para>
			Automatic message (request and reply) conversion is applied only if the provided callback is not an instance of
			<interfacename>ReceiveAndReplyMessageCallback</interfacename> - which provides a raw message exchange contract.
		</para>
		<para>
			The <interfacename>ReplyToAddressCallback</interfacename> is useful for cases requiring custom logic
			to determine the <code>replyTo</code> address at runtime against the received message
			and reply from the <interfacename>ReceiveAndReplyCallback</interfacename>.
			By default, <code>replyTo</code> information in the request message is used to route the reply.
		</para>
		<para>
			The following is an example of POJO-based receive and reply...
		</para>
		<programlisting language="java"><![CDATA[boolean received =
        this.template.receiveAndReply(ROUTE, new ReceiveAndReplyCallback<Order, Invoice>() {

                public Invoice handle(Order order) {
                        return processOrder(order);
                }
        });
if (received) {
        log.info("We received an order!");
}]]></programlisting>
    </section>

    <section id="async-consumer"><title>Asynchronous Consumer</title><para>For asynchronous Message
    reception, a dedicated component (not the
    <interfacename>AmqpTemplate</interfacename>) is involved. That component
    is a container for a Message consuming callback. We will look at the
    container and its properties in just a moment, but first we should look at
    the callback since that is where your application code will be integrated
    with the messaging system. There are a few options for the callback. The
    simplest of these is to implement the
    <interfacename>MessageListener</interfacename> interface:</para>
    <programlisting language="java"><![CDATA[public interface MessageListener {
    void onMessage(Message message);
}]]></programlisting> <para>If your callback logic depends upon the AMQP
    Channel instance for any reason, you may instead use the
    <interfacename>ChannelAwareMessageListener</interfacename>. It looks
    similar but with an extra parameter:</para> <programlisting
    language="java"><![CDATA[public interface ChannelAwareMessageListener {
    void onMessage(Message message, Channel channel) throws Exception;
}]]></programlisting> <para>If you prefer to maintain a stricter separation
    between your application logic and the messaging API, you can rely upon an
    adapter implementation that is provided by the framework. This is often
    referred to as "Message-driven POJO" support. When using the adapter, you
    only need to provide a reference to the instance that the adapter itself
    should invoke.</para>
    <programlisting language="java"><![CDATA[MessageListener listener = new MessageListenerAdapter(somePojo);]]></programlisting>
    <para>
    Now
    that you've seen the various options for the Message-listening callback,
    we can turn our attention to the container. Basically, the container
    handles the "active" responsibilities so that the listener callback can
    remain passive. The container is an example of a "lifecycle" component. It
    provides methods for starting and stopping. When configuring the
    container, you are essentially bridging the gap between an AMQP Queue and
    the <interfacename>MessageListener</interfacename> instance. You must
    provide a reference to the
    <interfacename>ConnectionFactory</interfacename> and the queue name or
    Queue instance(s) from which that listener should consume Messages. Here
    is the most basic example using the default implementation,
    <classname>SimpleMessageListenerContainer</classname> :
    </para>
    <programlisting language="java"><![CDATA[SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
container.setConnectionFactory(rabbitConnectionFactory);
container.setQueueNames("some.queue");
container.setMessageListener(new MessageListenerAdapter(somePojo));]]></programlisting>
    <para>
    As an "active" component, it's most common to create the listener
    container with a bean definition so that it can simply run in the
    background. This can be done via XML:
    </para>
    <programlisting language="xml"><![CDATA[<rabbit:listener-container connection-factory="rabbitConnectionFactory">
    <rabbit:listener queues="some.queue" ref="somePojo" method="handle"/>
</rabbit:listener-container>]]></programlisting>
    <para>
    Or, you may prefer to use the
    @Configuration style which will look very similar to the actual code
    snippet above:
    </para>
    <programlisting language="java"><![CDATA[@Configuration
public class ExampleAmqpConfiguration {

    @Bean
    public SimpleMessageListenerContainer messageListenerContainer() {
        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
        container.setConnectionFactory(rabbitConnectionFactory());
        container.setQueueName("some.queue");
        container.setMessageListener(exampleListener());
        return container;
    }

    @Bean
    public ConnectionFactory rabbitConnectionFactory() {
        CachingConnectionFactory connectionFactory =
            new CachingConnectionFactory("localhost");
        connectionFactory.setUsername("guest");
        connectionFactory.setPassword("guest");
        return connectionFactory;
    }

    @Bean
    public MessageListener exampleListener() {
        return new MessageListener() {
            public void onMessage(Message message) {
                System.out.println("received: " + message);
            }
        };
    }
}]]></programlisting>
    <para id="consumer-priority">
        Starting with <emphasis>RabbitMQ Version 3.2</emphasis>, the broker now supports consumer priority (see
        <ulink url="http://www.rabbitmq.com/blog/2013/12/16/using-consumer-priorities-with-rabbitmq/"/>).
        This is enabled by setting the <code>x-priority</code> argument on the consumer.
        The <classname>SimpleMessageListenerContainer</classname> now supports setting consumer arguments:
    </para>
    <programlisting language="java"><![CDATA[
container.setConsumerArguments(Collections. <String, Object> singletonMap("x-priority", Integer.valueOf(10)));]]></programlisting>
    <para>
        For convenience, the namespace provides the <code>priority</code> attribute on the
        <code>listener</code> element:
    </para>
    <programlisting language="xml"><![CDATA[<rabbit:listener-container connection-factory="rabbitConnectionFactory">
    <rabbit:listener queues="some.queue" ref="somePojo" method="handle" priority="10" />
</rabbit:listener-container>]]></programlisting>
	<para>
		Starting with <emphasis>version 1.3</emphasis> the queue(s) on which the container is listening can
		be modified at runtime; see <xref linkend="listener-queues" />.
	</para>
	<section id="lc-auto-delete">
		<title>'auto-delete' Queues</title>
		<para>
			When a container is configured to listen to <code>auto-delete</code> queue(s), or the queue has an
			<code>x-expires</code> option or the <ulink url="http://www.rabbitmq.com/ttl.html">Time-To-Live</ulink>
			policy is configured on the Broker, the queue is removed by the broker when the container is
			stopped	(last consumer is cancelled).
			Before <emphasis>version 1.3</emphasis>, the container could not be restarted because
			the queue was missing; the <classname>RabbitAdmin</classname> only automatically
			redeclares queues etc, when the connection is closed/opens, which does not happen
			when the container is stopped/started.
		</para>
		<para>
			Starting with <emphasis>version 1.3</emphasis>, the container will now use a
			<classname>RabbitAdmin</classname> to redeclare any missing queues during startup.
		</para>
		<para>
			You can also use conditional declaration (<xref linkend="conditional-declaration"/>)
			together with an <code>auto-startup="false"</code> admin to defer queue declaration
			until the container is started.
		</para>
		<programlisting language="xml"><![CDATA[<rabbit:queue id="otherAnon" declared-by="containerAdmin" />

<rabbit:direct-exchange name="otherExchange" auto-delete="true" declared-by="containerAdmin">
	<rabbit:bindings>
		<rabbit:binding queue="otherAnon" key="otherAnon" />
	</rabbit:bindings>
</rabbit:direct-exchange>

<rabbit:listener-container id="container2" auto-startup="false">
	<rabbit:listener id="listener2" ref="foo" queues="otherAnon" admin="containerAdmin" />
</rabbit:listener-container>

<rabbit:admin id="containerAdmin" connection-factory="rabbitConnectionFactory"
	auto-startup="false" />]]></programlisting>
		<para>
			In this case, the queue and exchange are declared by <code>containerAdmin</code>
			which has <code>auto-startup="false"</code> so the elements are not declared
			during context initialization. Also, the container is not started for the
			same reason. When the container is later started, it uses it's reference to
			<code>containerAdmin</code> to declare the elements.
		</para>
	</section>
    </section>
  </section>

  <section>
    <title>Message Converters</title>

    <para>The <interfacename>AmqpTemplate</interfacename> also defines several
    methods for sending and receiving Messages that will delegate to a
    <interfacename>MessageConverter</interfacename>. The
    <interfacename>MessageConverter</interfacename> itself is quite
    straightforward. It provides a single method for each direction: one for
    converting <emphasis>to</emphasis> a Message and another for converting
    <emphasis>from</emphasis> a Message. Notice that when converting to a
    Message, you may also provide properties in addition to the object. The
    "object" parameter typically corresponds to the Message body.</para>

    <programlisting language="java"><![CDATA[public interface MessageConverter {

    Message toMessage(Object object, MessageProperties messageProperties)
            throws MessageConversionException;

    Object fromMessage(Message message) throws MessageConversionException;

}]]></programlisting>

    <para>The relevant Message-sending methods on the
    <interfacename>AmqpTemplate</interfacename> are listed below. They
    are simpler than the methods we discussed previously because they
    do not require the <classname>Message</classname> instance.
    Instead, the <interfacename>MessageConverter</interfacename> is
    responsible for "creating" each <classname>Message</classname> by
    converting the provided object to the byte array for
    the <classname>Message</classname> body and then adding any
    provided <classname>MessageProperties</classname>.</para>

    <programlisting language="java"><![CDATA[void convertAndSend(Object message) throws AmqpException;

void convertAndSend(String routingKey, Object message) throws AmqpException;

void convertAndSend(String exchange, String routingKey, Object message)
    throws AmqpException;

void convertAndSend(Object message, MessagePostProcessor messagePostProcessor)
    throws AmqpException;

void convertAndSend(String routingKey, Object message,
    MessagePostProcessor messagePostProcessor) throws AmqpException;

void convertAndSend(String exchange, String routingKey, Object message,
    MessagePostProcessor messagePostProcessor) throws AmqpException;]]></programlisting>

    <para>On the receiving side, there are only two methods: one that accepts
    the queue name and one that relies on the template's "queue" property
    having been set.</para>

    <programlisting language="java"><![CDATA[Object receiveAndConvert() throws AmqpException;

Object receiveAndConvert(String queueName) throws AmqpException;]]></programlisting>
    <note>
      The <classname>MessageListenerAdapter</classname> mentioned in <xref linkend="async-consumer"/>
      also uses a <classname>MessageConverter</classname>.
    </note>
    <sect2>
      <title>SimpleMessageConverter</title>

      <para>The default implementation of the
      <interfacename>MessageConverter</interfacename> strategy is called
      <classname>SimpleMessageConverter</classname>. This is the converter
      that will be used by an instance of RabbitTemplate if you do not
      explicitly configure an alternative. It handles text-based content,
      serialized Java objects, and simple byte arrays.</para>

      <sect3>
        <title>Converting From a Message</title>

        <para>If the content type of the input Message begins with "text"
        (e.g. "text/plain"), it will also check for the content-encoding
        property to determine the charset to be used when converting the
        Message body byte array to a Java String. If no content-encoding
        property had been set on the input Message, it will use the "UTF-8"
        charset by default. If you need to override that default setting, you
        can configure an instance of
        <classname>SimpleMessageConverter</classname>, set its
        "defaultCharset" property and then inject that into a
        <classname>RabbitTemplate</classname> instance.</para>

        <para>If the content-type property value of the input Message is set
        to "application/x-java-serialized-object", the
        <classname>SimpleMessageConverter</classname> will attempt to
        deserialize (rehydrate) the byte array into a Java object. While that
        might be useful for simple prototyping, it's generally not recommended
        to rely on Java serialization since it leads to tight coupling between
        the producer and consumer. Of course, it also rules out usage of
        non-Java systems on either side. With AMQP being a wire-level
        protocol, it would be unfortunate to lose much of that advantage with
        such restrictions. In the next two sections, we'll explore some
        alternatives for passing rich domain object content without relying on
        Java serialization.</para>

        <para>For all other content-types, the
        <classname>SimpleMessageConverter</classname> will return the Message
        body content directly as a byte array.</para>
      </sect3>

      <sect3>
        <title>Converting To a Message</title>

        <para>When converting to a Message from an arbitrary Java Object, the
        <classname>SimpleMessageConverter</classname> likewise deals with byte
        arrays, Strings, and Serializable instances. It will convert each of
        these to bytes (in the case of byte arrays, there is nothing to
        convert), and it will set the content-type property accordingly. If
        the Object to be converted does not match one of those types, the
        Message body will be null.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>JsonMessageConverter and Jackson2JsonMessageConverter</title>

      <para>As mentioned in the previous section, relying on Java
      serialization is generally not recommended. One rather common
      alternative that is more flexible and portable across different
      languages and platforms is JSON (JavaScript Object Notation). Two
      implementations are available and can be configured on any
      <classname>RabbitTemplate</classname> instance to override its usage of
      the <classname>SimpleMessageConverter</classname> default.
      The <classname>JsonMessageConverter</classname> which uses the
      <code>org.codehaus.jackson</code> 1.x library
      and <classname>Jackson2JsonMessageConverter</classname> which uses the
      <code>com.fasterxml.jackson</code> 2.x library.
      </para>

      <programlisting language="xml"><![CDATA[<bean class="org.springframework.amqp.rabbit.core.RabbitTemplate">
    <property name="connectionFactory" ref="rabbitConnectionFactory"/>
    <property name="messageConverter">
        <bean class="org.springframework.amqp.support.converter.JsonMessageConverter">
            <!-- if necessary, override the DefaultClassMapper -->
            <property name="classMapper" ref="customClassMapper"/>
        </bean>
    </property>
</bean>]]></programlisting>

      <programlisting language="xml"><![CDATA[<bean class="org.springframework.amqp.rabbit.core.RabbitTemplate">
    <property name="connectionFactory" ref="rabbitConnectionFactory"/>
    <property name="messageConverter">
        <bean class="org.springframework.amqp.support.converter.Jackson2JsonMessageConverter">
            <!-- if necessary, override the DefaultClassMapper -->
            <property name="classMapper" ref="customClassMapper"/>
        </bean>
    </property>
</bean>]]></programlisting>
      <para>As shown above, the <classname>JsonMessageConverter</classname> and <classname>Jackson2JsonMessageConverter</classname> uses a
      <classname>DefaultClassMapper</classname> by default. Type information is
      added to (and retrieved from) the <classname>MessageProperties</classname>.
      If an inbound message does not contain type information in the
      <classname>MessageProperties</classname>, but you know the expected type,
      you can configure a static type using the <code>defaultType</code> property</para>

      <programlisting language="xml"><![CDATA[<bean id="jsonConverterWithDefaultType"
      class="o.s.amqp.support.converter.JsonMessageConverter">
    <property name="classMapper">
        <bean class="org.springframework.amqp.support.converter.DefaultClassMapper">
            <property name="defaultType" value="foo.PurchaseOrder"/>
        </bean>
    </property>
</bean>]]></programlisting>

      <programlisting language="xml"><![CDATA[<bean id="jsonConverterWithDefaultType"
      class="o.s.amqp.support.converter.Jackson2JsonMessageConverter">
    <property name="classMapper">
        <bean class="org.springframework.amqp.support.converter.DefaultClassMapper">
            <property name="defaultType" value="foo.PurchaseOrder"/>
        </bean>
    </property>
</bean>]]></programlisting>
    </sect2>

    <sect2>
      <title>MarshallingMessageConverter</title>

      <para>Yet another option is the
      <classname>MarshallingMessageConverter</classname>. It delegates to the
      Spring OXM library's implementations of the
      <interfacename>Marshaller</interfacename> and
      <interfacename>Unmarshaller</interfacename> strategy interfaces. You can
      read more about that library <ulink
      url="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/oxm.html">here</ulink>.
      In terms of configuration, it's most common to provide the constructor
      argument only since most implementations of
      <interfacename>Marshaller</interfacename> will also implement
      <interfacename>Unmarshaller</interfacename>.</para>

      <programlisting language="xml"><![CDATA[<bean class="org.springframework.amqp.rabbit.core.RabbitTemplate">
    <property name="connectionFactory" ref="rabbitConnectionFactory"/>
    <property name="messageConverter">
        <bean class="org.springframework.amqp.support.converter.MarshallingMessageConverter">
            <constructor-arg ref="someImplemenationOfMarshallerAndUnmarshaller"/>
        </bean>
    </property>
</bean>]]></programlisting>
    </sect2>
  </section>

  <section id="request-reply">
    <title>Request/Reply Messaging</title>

    <para>The <classname>AmqpTemplate</classname> also provides a variety of
    <methodname>sendAndReceive</methodname> methods that accept the same argument options
    that you have seen above for the one-way send operations (exchange, routingKey, and Message).
    Those methods are quite useful for request/reply scenarios since they handle the configuration
    of the necessary "reply-to" property before sending and can listen for the reply message on an
    exclusive Queue that is created internally for that purpose.</para>

    <para>Similar request/reply methods are also available where the <classname>MessageConverter</classname>
    is applied to both the request and reply. Those methods are named <methodname>convertSendAndReceive</methodname>.
    See the Javadoc of <classname>AmqpTemplate</classname> for more detail.</para>
    <para>
    By default, a new temporary queue is used for each reply. However, a single reply queue can be configured on the template,
    which can be more efficient, and also allows you to set arguments on that queue. In this case, however,
    you must also provide a &lt;reply-listener/&gt; sub element. This element provides a listener container for the
    reply queue, with the template being the listener. All of the <xref linkend="containerAttributes" /> attributes
    allowed on a &lt;listener-container/&gt; are allowed on the element, except for connection-factory and
    message-converter, which are inherited from the template's configuration.
    </para>
    <programlisting language="xml"><![CDATA[<rabbit:template id="amqpTemplate"
        connection-factory="connectionFactory" reply-queue="replies">
    <rabbit:reply-listener/>
</rabbit:template>
]]></programlisting>
    <para>
    While the container and template share a connection factory, they do not share a channel and therefore requests
    and replies are not performed within the same transaction (if transactional).
    </para>
    <section>
      <title>Message Correlation With A Reply Queue</title>
      <para>
      When using a fixed reply queue, it is necessary to provide correlation data so that replies can be correlated
      to requests. See <ulink url="http://www.rabbitmq.com/tutorials/tutorial-six-java.html">
      RabbitMQ Remote Procedure Call (RPC)</ulink>. By default, the standard <code>correlationId</code> property will
      be used to hold the correlation data. However, if you wish to use a custom propertry to hold correlation
      data, you can set the <code>correlation-key</code> attribute on the &lt;rabbit-template/&gt;. Explicitly
      setting the attribute to <code>correlationId</code> is the same as omitting the attribute.
      Of course, the client and server must use the same header for correlation data.
      </para>
      <note>
      Spring AMQP version 1.1 used a custom property <code>spring_reply_correlation</code> for this data. If you
      wish to revert to this behavior with the current version, perhaps to maintain compatibility with another
      application using 1.1, you must set the attribute to <code>spring_reply_correlation</code>.
      </note>
      <section>
        <title>Reply Listener Container</title>
        <para>
        When using a fixed reply queue, a <classname>SimpleListenerContainer</classname> is used to receive the
        replies; with the <classname>RabbitTemplate</classname> being the <interfacename>MessageListener</interfacename>.
        When defining a template with the <code>&lt;rabbit:template/&gt;</code> namespace element, as shown above,
        the parser defines the container and wires in the template as the listener.
        </para>
        <note>
        When the template does not use a fixed <code>replyQueue</code>, a listener container is not needed.
        </note>
        <para>
        If you define your <classname>RabbitTemplate</classname> as a <code>&lt;bean/&gt;</code>, or using an
        <code>@Configuration</code> class to define it as an <code>@Bean</code>, or when creating
        the template programmatically, you will need to define and
        wire up the reply listener container yourself. If you fail to do this, the template will never receive
        the replies and will eventually time out and return null as the reply to a call to a
        <code>sendAndReceive</code> method.
        </para>
        <important>
        When wiring the reply listener and template yourself, it is important to ensure that the template's
        <code>replyQueue</code> and the container's <code>queues</code> (or <code>queueNames</code>) properties
        refer to the same queue. The template inserts the reply queue into the outbound message
        <code>replyTo</code> property.
        </important>
        <para>
        The following are examples of how to manually wire up the beans.
        </para>
        <programlisting language="xml"><![CDATA[<bean id="amqpTemplate" class="org.springframework.amqp.rabbit.core.RabbitTemplate">
    <constructor-arg ref="connectionFactory" />
    <property name="exchange" value="foo.exchange" />
    <property name="routingKey" value="foo" />
    <property name="replyQueue" ref="replyQ" />
    <property name="replyTimeout" value="600000" />
</bean>

<bean class="org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer">
    <constructor-arg ref="connectionFactory" />
    <property name="queues" ref="replyQ" />
    <property name="messageListener" ref="amqpTemplate" />
</bean>

<rabbit:queue id="replyQ" name="my.reply.queue" />]]></programlisting>

        <programlisting language="java"><![CDATA[    @Bean
    public RabbitTemplate amqpTemplate() {
        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory());
        rabbitTemplate.setMessageConverter(msgConv());
        rabbitTemplate.setReplyQueue(replyQueue());
        rabbitTemplate.setReplyTimeout(60000);
        return rabbitTemplate;
    }

    @Bean
    public SimpleMessageListenerContainer replyListenerContainer() {
        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
        container.setConnectionFactory(connectionFactory());
        container.setQueues(replyQueue());
        container.setMessageListener(amqpTemplate());
        return container;
    }

    @Bean
    public Queue replyQueue() {
        return new Queue("my.reply.queue");
    }]]></programlisting>
      <para>
        A complete example of a <classname>RabbitTemplate</classname> wired with a fixed reply queue, together
        with a "remote" listener container that handles the request and returns the reply is shown in
        <ulink url="https://github.com/spring-projects/spring-amqp/tree/master/spring-rabbit/src/test/java/org/springframework/amqp/rabbit/listener/JavaConfigFixedReplyQueueTests.java"
        >this test case</ulink>.
      </para>
      <important>
        <para>
          When the reply times out (<code>replyTimeout</code>), the <code>sendAndReceive()</code> methods return
          null.
        </para>
        <para>
          Prior to <emphasis>version 1.3.6</emphasis>, late replies for timed out messages were simply logged. Now, if
          a late reply is received, it is rejected (the template throws an
          <classname>AmqpRejectAndDontRequeueException</classname>). If the reply queue is configured to send
          rejected messages to a dead letter exchange, the reply can be retrieved for later analysis. Simply
          bind a queue to the configured dead letter exchange with a routing key equal to the reply queue's
          name.
        </para>
        <para>
          Refer to the <ulink url="https://www.rabbitmq.com/dlx.html">RabbitMQ Dead Letter Documentation</ulink>
          for more information about configuring dead lettering. You can also take a look at the
          <classname>FixedReplyQueueDeadLetterTests</classname> test case for an example.
        </para>
      </important>
      </section>
    </section>
    <section id="remoting">
      <title>Spring Remoting with AMQP</title>
      <para>
        The Spring Framework has a general remoting capability, allowing
        <ulink url="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/remoting.html">
        Remote Procedure Calls (RPC)</ulink> using various transports.
        Spring-AMQP supports a similar mechanism with a <classname>AmqpProxyFactoryBean</classname> on the client
        and a <classname>AmqpInvokerServiceExporter</classname> on the server. This provides RPC over AMQP.
        On the client side, a <classname>RabbitTemplate</classname> is used as described above; on the server side,
        the invoker (configured as a <interfacename>MessageListener</interfacename>) receives the message, invokes
        the configured service, and returns the reply using the inbound message's <code>replyTo</code> information.
      </para>
      <para>
        The client factory bean can be injected into any bean (using its <code>serviceInterface</code>); the client
        can then invoke methods on the proxy, resulting in remote execution over AMQP.
      </para>
      <note>
        <para>
          With the default <interfacename>MessageConverter</interfacename>s, the method paramters and returned
          value must be instances of <interfacename>Serializable</interfacename>.
         </para>
         <para>
           On the server side, the <classname>AmqpInvokerServiceExporter</classname> has
           both <interfacename>AmqpTemplate</interfacename> and <interfacename>MessageConverter</interfacename>
           properties. Currently, the template's <interfacename>MessageConverter</interfacename> is not
           used. If you need to supply a custom message converter, then you should provide it using
           the <code>messageConverter</code> property. On the client side, a custom message converter
           can be added to the <interfacename>AmqpTemplate</interfacename> which is provided to the
           <classname>AmqpProxyFactoryBean</classname> using its <code>amqpTemplate</code> property.
         </para>
      </note>
      <para>
        Sample client and server configurations are shown below.
      </para>
      <programlisting language="xml"><![CDATA[<bean id="client"
	class="org.springframework.amqp.remoting.client.AmqpProxyFactoryBean">
	<property name="amqpTemplate" ref="template" />
	<property name="serviceInterface" value="foo.ServiceInterface" />
</bean>

<rabbit:connection-factory id="connectionFactory" />

<rabbit:template id="template" connection-factory="connectionFactory" reply-timeout="2000"
	routing-key="remoting.binding" exchange="remoting.exchange" />

<rabbit:admin connection-factory="connectionFactory" />

<rabbit:queue name="remoting.queue" />

<rabbit:direct-exchange name="remoting.exchange">
	<rabbit:bindings>
		<rabbit:binding queue="remoting.queue" key="remoting.binding" />
	</rabbit:bindings>
</rabbit:direct-exchange>]]></programlisting>
      <programlisting language="xml"><![CDATA[<bean id="listener"
	class="org.springframework.amqp.remoting.service.AmqpInvokerServiceExporter">
	<property name="serviceInterface" value="foo.ServiceInterface" />
	<property name="service" ref="service" />
	<property name="amqpTemplate" ref="template" />
</bean>

<bean id="service" class="foo.ServiceImpl" />

<rabbit:connection-factory id="connectionFactory" />

<rabbit:template id="template" connection-factory="connectionFactory" />

<rabbit:queue name="remoting.queue" />

<rabbit:listener-container connection-factory="connectionFactory">
	<rabbit:listener ref="listener" queue-names="remoting.queue" />
</rabbit:listener-container>]]></programlisting>
      <important>
        The <classname>AmqpInvokerServiceExporter</classname> can only process properly
        formed messages, such as those sent from the <classname>AmqpProxyFactoryBean</classname>.
        If it receives a message that it cannot interpret, a serialized
        <classname>RuntimeException</classname> will be sent as a reply. If the message has
        no <code>replyToAddress</code> property, the message will be rejected and permanently lost if no
        Dead Letter Exchange has been configured.
      </important>
    </section>
  </section>

  <section id="broker-configuration">
    <title>Configuring the broker</title>

    <para>The AMQP specification describes how the protocol can be used to
    configure Queues, Exchanges and Bindings on the broker. These operations
    which are portable from the 0.8 specification and higher are present in
    the AmqpAdmin interface in the org.springframework.amqp.core package. The
    RabbitMQ implementation of that class is RabbitAdmin located in the
    org.springframework.amqp.rabbit.core package.</para>

    <para>The AmqpAdmin interface is based on using the Spring AMQP domain
    abstractions and is shown below:</para>

    <programlisting language="java"><![CDATA[public interface AmqpAdmin {

    // Exchange Operations

    void declareExchange(Exchange exchange);

    void deleteExchange(String exchangeName);

    // Queue Operations

    Queue declareQueue();

    String declareQueue(Queue queue);

    void deleteQueue(String queueName);

    void deleteQueue(String queueName, boolean unused, boolean empty);

    void purgeQueue(String queueName, boolean noWait);

    // Binding Operations

    void declareBinding(Binding binding);

    void removeBinding(Binding binding);

    Properties getQueueProperties(String queueName);

}]]></programlisting>

    <para>The no-arg declareQueue() method defines a queue on the broker whose name
    is automatically generated. The additional properties of this auto-generated
    queue are <code>exclusive=true</code>, <code>autoDelete=true</code>, and <code>durable=false</code>.</para>

    <para>The <code>declareQueue(Queue queue)</code> method takes a <classname>Queue</classname> object
		and returns the name of the declared queue. This is useful if you wish the broker to generate the
		queue's name. This is in contrast to an <classname>AnonymousQueue</classname> where the
		framework generates a unique (<code>UUID</code>) name and sets <code>durable</code> to
		<code>false</code> and <code>exlusive, autoDelete</code> to <code>true</code>.
		If the provided <classname>Queue</classname>'s <code>name</code> property
		is an empty String,
		the Broker declares the queue with a generated name and that name is returned to the caller.
		The <classname>Queue</classname> object itself is not changed.
		This functionality
		can only be used programmatically by invoking the <classname>RabbitAdmin</classname> directly.
		It is not supported for auto-declaration by the admin by defining a queue declaratively in the
		application context.
		A <code>&lt;rabbit:queue/&gt;</code> with an empty, or missing, <code>name</code> will
		always create an <classname>AnonymousQueue</classname>. This is because the name will
		change if redeclared due to a connection failure. Declarative queues must have fixed names because they
		might be referenced elsewhere in the context, for example, in a listener:
		<programlisting language="xml"><![CDATA[<rabbit:listener-container>
    <rabbit:listener ref="listener" queue-names="#{someQueue.name}" />
</rabbit:listener-container>]]></programlisting>
		See <xref linkend="automatic-declaration" />.
	</para>

    <para>The RabbitMQ implementation of this interface is RabbitAdmin which
    when configured using Spring XML would look like this:
    </para>
    <programlisting language="xml"><![CDATA[<rabbit:connection-factory id="connectionFactory"/>

<rabbit:admin id="amqpAdmin" connection-factory="connectionFactory"/>]]></programlisting>

    <para>When the <classname>CachingConnectionFactory</classname> cache mode
    is <code>CHANNEL</code> (the default),
    the <classname>RabbitAdmin</classname> implementation does automatic
    lazy declaration of <classname>Queues</classname>,
    <classname>Exchanges</classname> and <classname>Bindings</classname>
    declared in the same <classname>ApplicationContext</classname>. These
    components will be declared as son as a <classname>Connection</classname>
    is opened to the broker. There are some namespace features that make this
    very convenient, e.g. in the Stocks sample application we have:</para>

    <programlisting language="xml"><![CDATA[<rabbit:queue id="tradeQueue"/>

<rabbit:queue id="marketDataQueue"/>

<fanout-exchange name="broadcast.responses"
                 xmlns="http://www.springframework.org/schema/rabbit">
    <bindings>
        <binding queue="tradeQueue"/>
    </bindings>
</fanout-exchange>

<topic-exchange name="app.stock.marketdata"
                xmlns="http://www.springframework.org/schema/rabbit">
    <bindings>
        <binding queue="marketDataQueue" pattern="${stocks.quote.pattern}"/>
    </bindings>
</topic-exchange>]]></programlisting>

    <para>In the example above we are using anonymous Queues (actually
    internally just Queues with names generated by the framework, not by the
    broker) and refer to them by ID. We can also declare Queues with explicit
    names, which also serve as identifiers for their bean definitions in the
    context. E.g.</para>

    <programlisting language="xml"><![CDATA[<rabbit:queue name="stocks.trade.queue"/>]]></programlisting>

	<tip>
		You can provide both an <emphasis>id</emphasis> and a <emphasis>name</emphasis> attribute.
		This allows you to refer to the queue (for example in a binding) by an id that is
		independent of the queue name. It also allows standard Spring features such as
		property placeholders, and SpEL expressions for the queue name; these features
		are not available when using the name as the bean identifier.
	</tip>

	<para>Queues can be configured with additional arguments, for example,
	'x-message-ttl' or 'x-ha-policy'. Using the namespace support, they are provided in the form of
	a Map of argument name/argument value pairs, using the
	&lt;rabbit:queue-arguments&gt; element.</para>

    <programlisting language="xml"><![CDATA[<rabbit:queue name="withArguments">
    <rabbit:queue-arguments>
        <entry key="x-ha-policy" value="all"/>
    </rabbit:queue-arguments>
</rabbit:queue>]]></programlisting>

	<para>By default, the arguments are assumed to be strings. For arguments
	of other types, the type needs to be provided.</para>

	<programlisting language="xml"><![CDATA[<rabbit:queue name="withArguments">
    <rabbit:queue-arguments value-type="java.lang.Long">
        <entry key="x-message-ttl" value="100"/>
    </rabbit:queue-arguments>
</rabbit:queue>]]></programlisting>

	<para>When providing arguments of mixed types, the type is provided for each entry element:</para>

	<programlisting language="xml"><![CDATA[<rabbit:queue name="withArguments">
    <rabbit:queue-arguments>
        <entry key="x-message-ttl">
            <value type="java.lang.Long">100</value>
        </entry>
        <entry key="x-ha-policy" value="all"/>
    </rabbit:queue-arguments>
</rabbit:queue>]]></programlisting>

	<para>With Spring Framework 3.2 and later, this can be declared a little more succinctly:</para>

	<programlisting language="xml"><![CDATA[<rabbit:queue name="withArguments">
    <rabbit:queue-arguments>
        <entry key="x-message-ttl" value="100" value-type="java.lang.Long"/>
        <entry key="x-ha-policy" value="all"/>
    </rabbit:queue-arguments>
</rabbit:queue>]]></programlisting>

	<important>
		<para>
			The RabbitMQ broker will not allow declaration of a queue with mismatched
			arguments. For example, if a <code>queue</code> already exists with no
			<code>time to live</code> argument, and you attempt to declare it with,
			say, <code>key="x-message-ttl" value="100"</code>, an exception will be
			thrown.
		</para>
		<para>
			By default, the <classname>RabbitAdmin</classname> will immediately stop
			processing all declarations when any exception occurs; this could cause
			downstream issues - such as a <emphasis>listener container</emphasis> failing
			to initialize because another queue (defined after the one in error) is not
			declared.
		</para>
		<para>
			This behavior can be modified by setting the <code>ignore-declaration-failures</code>
			attribute to <code>true</code> on the <classname>RabbitAdmin</classname>.
			This option instructs the <classname>RabbitAdmin</classname> to log
			the exception, and continue declaring other elements.
		</para>
	</important>

	<para id="headers-exchange">
		Starting with <emphasis>version 1.3</emphasis> the HeadersExchange can be configured to
		match on multiple headers; you can also specify whether any or all headers must match:
	</para>
	<programlisting language="xml"><![CDATA[<rabbit:headers-exchange name="headers-test">
	<rabbit:bindings>
		<rabbit:binding queue="bucket">
			<rabbit:binding-arguments>
				<entry key="foo" value="bar"/>
				<entry key="baz" value="qux"/>
				<entry key="x-match" value="all"/>
			</rabbit:binding-arguments>
		</rabbit:binding>
	</rabbit:bindings>
</rabbit:headers-exchange>]]></programlisting>

    <para>To see how to use Java to configure the AMQP infrastructure, look at
    the Stock sample application, where there is the <code>@Configuration</code>
    class <classname>AbstractStockRabbitConfiguration</classname> which in
    turn has RabbitClientConfiguration and RabbitServerConfiguration
    subclasses. The code for AbstractStockRabbitConfiguration is shown
    below</para>

    <programlisting language="java"><![CDATA[@Configuration
public abstract class AbstractStockAppRabbitConfiguration {

    @Bean
    public ConnectionFactory connectionFactory() {
        CachingConnectionFactory connectionFactory =
            new CachingConnectionFactory("localhost");
        connectionFactory.setUsername("guest");
        connectionFactory.setPassword("guest");
        return connectionFactory;
    }

    @Bean
    public RabbitTemplate rabbitTemplate() {
        RabbitTemplate template = new RabbitTemplate(connectionFactory());
        template.setMessageConverter(jsonMessageConverter());
        configureRabbitTemplate(template);
        return template;
    }

    @Bean
    public MessageConverter jsonMessageConverter() {
        return new JsonMessageConverter();
    }

    @Bean
    public TopicExchange marketDataExchange() {
        return new TopicExchange("app.stock.marketdata");
    }

    // additional code omitted for brevity

}]]></programlisting>

    <para>In the Stock application, the server is configured using the
    following @Configuration class:</para>

    <programlisting language="java"><![CDATA[@Configuration
public class RabbitServerConfiguration extends AbstractStockAppRabbitConfiguration  {

    @Bean
    public Queue stockRequestQueue() {
        return new Queue("app.stock.request");
    }
}]]></programlisting>

    <para>This is the end of the whole inheritance chain of @Configuration
    classes. The end result is the the TopicExchange and Queue will be
    declared to the broker upon application startup. There is no binding of
    the TopicExchange to a queue in the server configuration, as that is done
    in the client application. The stock request queue however is
    automatically bound to the AMQP default exchange - this behavior is
    defined by the specification.</para>

    <para>The client @Configuration class is a little more interesting and is
    shown below.</para>

    <programlisting language="java"><![CDATA[@Configuration
public class RabbitClientConfiguration extends AbstractStockAppRabbitConfiguration {

    @Value("${stocks.quote.pattern}")
    private String marketDataRoutingKey;

    @Bean
    public Queue marketDataQueue() {
        return amqpAdmin().declareQueue();
    }

    /**
     * Binds to the market data exchange. Interested in any stock quotes
     * that match its routing key.
     */
    @Bean
    public Binding marketDataBinding() {
        return BindingBuilder.bind(
                marketDataQueue()).to(marketDataExchange()).with(marketDataRoutingKey);
    }

    // additional code omitted for brevity

}]]></programlisting>

    <para>The client is declaring another queue via the declareQueue() method
    on the AmqpAdmin, and it binds that queue to the market data exchange with
    a routing pattern that is externalized in a properties file.</para>
    <section id="conditional-declaration">
      <title>Conditional Declaration</title>
      <para>
        By default, all queues, exchanges, and bindings are declared by all <classname>
        RabbitAdmin</classname> instances (that have <code>auto-startup="true"</code>)
        in the application context.
      </para>
      <note>
        Starting with the 1.2 release, it is possible to conditionally
        declare these elements. This is particularly useful when an application
        connects to multiple brokers and needs to specify with which broker(s) a
        particular element should be declared.
      </note>
      <para>
        The classes representing these elements
        implement <interfacename>Declarable</interfacename> which
        has two methods: <code>shouldDeclare()</code> and <code>getDeclaringAdmins()</code>.
        The <classname>RabbitAdmin</classname> uses these methods to determine whether
        a particular instance should actually process the declarations on its
        <interfacename>Connection</interfacename>.
      </para>
      <para>
        The properties are available as attributes in the namespace, as shown in the following
        examples.
      </para>
      <programlisting language="xml"><![CDATA[<rabbit:admin id="admin1" connection-factory="CF1" />

<rabbit:admin id="admin2" connection-factory="CF2" />

<rabbit:queue id="declaredByBothAdminsImplicitly" />

<rabbit:queue id="declaredByBothAdmins" declared-by="admin1, admin2" />

<rabbit:queue id="declaredByAdmin1Only" declared-by="admin1" />

<rabbit:queue id="notDeclaredByAny" auto-declare="false" />

<rabbit:direct-exchange name="direct" declared-by="admin1, admin2">
	<rabbit:bindings>
		<rabbit:binding key="foo" queue="bar"/>
	</rabbit:bindings>
</rabbit:direct-exchange>]]></programlisting>
      <note>
        The <code>auto-declare</code> attribute is <code>true</code> by default and if the <code>declared-by</code>
        is not supplied (or is empty) then all <classname>RabbitAdmin</classname>s will declare the
        object (as long as the admin's <code>auto-startup</code> attribute is true; the default).
      </note>
      <para>
        Similarly, you can use Java-based <code>@Configuration</code> to achieve the same
        effect. In this example, the components will be declared by <code>admin1</code> but not
        <code>admin2</code>:
      </para>
      <programlisting language="java"><![CDATA[@Bean
public RabbitAdmin admin() {
	RabbitAdmin rabbitAdmin = new RabbitAdmin(cf1());
	rabbitAdmin.afterPropertiesSet();
	return rabbitAdmin;
}

@Bean
public RabbitAdmin admin2() {
	RabbitAdmin rabbitAdmin = new RabbitAdmin(cf2());
	rabbitAdmin.afterPropertiesSet();
	return rabbitAdmin;
}

@Bean
public Queue queue() {
	Queue queue = new Queue("foo");
	queue.setAdminsThatShouldDeclare(admin());
	return queue;
}

@Bean
public Exchange exchange() {
	DirectExchange exchange = new DirectExchange("bar");
	exchange.setAdminsThatShouldDeclare(admin());
	return exchange;
}

@Bean
public Binding binding() {
	Binding binding = new Binding("foo", DestinationType.QUEUE, exchange().getName(), "foo", null);
	binding.setAdminsThatShouldDeclare(admin());
	return binding;
}]]></programlisting>
    </section>
  </section>

  <section id="exception-handling">
    <title>Exception Handling</title>

    <para>Many operations with the RabbitMQ Java client can throw checked
    Exceptions. For example, there are a lot of cases where IOExceptions may
    be thrown. The RabbitTemplate, SimpleMessageListenerContainer, and other
    Spring AMQP components will catch those Exceptions and convert into one of
    the Exceptions within our runtime hierarchy. Those are defined in the
    'org.springframework.amqp' package, and AmqpException is the base of the
    hierarchy.</para>

    <para>
      When a listener throws an exception, it is wrapped in a
      <classname>ListenerExecutionFailedException</classname> and, normally the message
      is rejected and requeued by the broker. Setting <code>defaultRequeueRejected</code>
      to false will cause messages to be discarded (or routed to a dead letter exchange).
      As discussed in <xref linkend="async-listeners"/>, the listener can throw an
      <classname>AmqpRejectAndDontRequeueException</classname> to conditionally control
      this behavior.
    </para>
    <para>
      However, there is a class of errors where the listener cannot control the behavior.
      When a message that cannot be converted is encountered (for example an invalid
      <code>content_encoding</code> header), the <classname>MessageConversionException</classname>
      is thrown before the message reaches user code. With <code>defaultRequeueRejected</code>
      set to <code>true</code> (default), such messages would be redelivered over and over.
      Before <emphasis>version 1.3.2</emphasis>,
      users needed to write a custom <interface>ErrorHandler</interface>, as discussed
      in <xref linkend="exception-handling"/> to avoid this situation.
    </para>
    <para>
      Starting with <emphasis>version 1.3.2</emphasis>, the default
      <interfacename>ErrorHandler</interfacename> is now a
      <classname>ConditionalRejectingErrorHandler</classname> which will reject (and not
      requeue) messages that fail with a <classname>MessageConversionException</classname>.
      An instance of this error handler can be configured with a
      <interfacename>FatalExceptionStrategy</interfacename> so users can provide
      their own rules for conditional message rejection, e.g. a delegate implementation to the
	  <classname>BinaryExceptionClassifier</classname> from Spring Retry (<xref linkend="async-listeners"/>).
      In addition, the <classname>ListenerExecutionFailedException</classname> now has a
      <code>failedMessage</code> property which can be used in the decision.
      If the <code>FatalExceptionStrategy.isFatal()</code> method returns <code>true</code>,
      the error handler throws an <classname>AmqpRejectAndDontRequeueException</classname>.
      The default <interface>FatalExceptionStrategy</interface> logs a warning message.
    </para>
  </section>

  <section>
    <title>Transactions</title>

    <para>The Spring Rabbit framework has support for automatic transaction
    management in the synchronous and asynchronous use cases with a number of
    different semantics that can be selected declaratively, as is familiar to
    existing users of Spring transactions. This makes many if not most common
    messaging patterns very easy to implement.</para>

    <para>There are two ways to signal the desired transaction semantics to
    the framework. In both the <classname>RabbitTemplate</classname> and
    <classname>SimpleMessageListenerContainer</classname> there is a flag
    <code>channelTransacted</code> which, if true, tells the framework to use
    a transactional channel and to end all operations (send or receive) with a
    commit or rollback depending on the outcome, with an exception signaling
    a rollback. Another signal is to provide an external transaction with one
    of Spring's <classname>PlatformTransactionManager</classname>
    implementations as a context for the ongoing operation. If there is
    already a transaction in progress when the framework is sending or
    receiving a message, and the <code>channelTransacted</code> flag is true,
    then the commit or rollback of the messaging transaction will be deferred
    until the end of the current transaction. If the
    <code>channelTransacted</code> flag is false, then no transaction
    semantics apply to the messaging operation (it is auto-acked).</para>

    <para>The <classname>channelTransacted</classname> flag is a configuration
    time setting: it is declared and processed once when the AMQP components
    are created, usually at application startup. The external transaction is
    more dynamic in principle because the system responds to the current
    Thread state at runtime, but in practice is often also a configuration
    setting, when the transactions are layered onto an application
    declaratively.</para>

    <para>For synchronous use cases with <classname>RabbitTemplate</classname>
    the external transaction is provided by the caller, either declaratively
    or imperatively according to taste (the usual Spring transaction model).
    An example of a declarative approach (usually preferred because it is
    non-invasive), where the template has been configured with
    <code>channelTransacted=true</code>:</para>

    <programlisting language="java"><![CDATA[@Transactional
public void doSomething() {
    String incoming = rabbitTemplate.receiveAndConvert();
    // do some more database processing...
    String outgoing = processInDatabaseAndExtractReply(incoming);
    rabbitTemplate.convertAndSend(outgoing);
}]]></programlisting>

    <para>A String payload is received, converted and sent as a message body
    inside a method marked as @Transactional, so if the database processing
    fails with an exception, the incoming message will be returned to the
    broker, and the outgoing message will not be sent. This applies to any
    operations with the <classname>RabbitTemplate</classname> inside a chain
    of transactional methods (unless the <classname>Channel</classname> is
    directly manipulated to commit the transaction early for instance).</para>

    <para>For asynchronous use cases with
    <classname>SimpleMessageListenerContainer</classname> if an external
    transaction is needed it has to be requested by the container when it sets
    up the listener. To signal that an external transaction is required the
    user provides an implementation of
    <classname>PlatformTransactionManager</classname> to the container when it
    is configured. For example:</para>

    <programlisting language="java"><![CDATA[@Configuration
public class ExampleExternalTransactionAmqpConfiguration {

    @Bean
    public SimpleMessageListenerContainer messageListenerContainer() {
        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
        container.setConnectionFactory(rabbitConnectionFactory());
        container.setTransactionManager(transactionManager());
        container.setChannelTransacted(true);
        container.setQueueName("some.queue");
        container.setMessageListener(exampleListener());
        return container;
    }

}]]></programlisting>

    <para>In the example above, the transaction manager is added as a
    dependency injected from another bean definition (not shown), and the
    <code>channelTransacted</code> flag is also set to true. The effect is
    that if the listener fails with an exception the transaction will be
    rolled back, and the message will also be returned to the broker.
    Significantly, if the transaction fails to commit (e.g. a database
    constraint error, or connectivity problem), then the AMQP transaction will
    also be rolled back, and the message will be returned to the broker. This is
    sometimes known as a Best Efforts 1 Phase Commit, and is a very powerful
    pattern for reliable messaging. If the <code>channelTransacted</code> flag
    was set to false in the example above, which is the default, then the
    external transaction would still be provided for the listener, but all
    messaging operations would be auto-acked, so the effect is to commit the
    messaging operations even on a rollback of the business operation.</para>

    <section>
      <title>A note on Rollback of Received Messages</title>

      <para>AMQP transactions only apply to messages and acks sent to the
      broker, so when there is a rollback of a Spring transaction and a
      message has been received, what Spring AMQP has to do is not just
      rollback the transaction, but also manually reject the message (sort of
      a nack, but that's not what the specification calls it). The action
      taken on message rejection is independent of transactions and
      depends on the <code>defaultRequeueRejected</code>
      property (default <code>true</code>). For more information about
      rejecting failed messages, see <xref linkend="async-listeners" />.</para>
      <para>For more information about RabbitMQ transactions, and their limitations,
      refer to <ulink url="http://www.rabbitmq.com/semantics.html">
      RabbitMQ Broker Semantics</ulink>.</para>
      <note>Prior to <emphasis>RabbitMQ 2.7.0</emphasis>, such messages
      (and any that are unacked when a channel is closed or aborts) went to the
      back of the queue on a Rabbit broker, since 2.7.0, rejected messages
      go to the front of the queue, in a similar manner to JMS rolled
      back messages.</note>
    </section>
    <section>
      <title>Using the RabbitTransactionManager</title>
      <para>
        The
        <ulink url="http://static.springsource.org/spring-amqp/docs/latest_ga/api/org/springframework/amqp/rabbit/transaction/RabbitTransactionManager.html">RabbitTransactionManager</ulink>
        is an alternative to executing Rabbit operations within, and synchronized
        with, external transactions. This Transaction Manager is an implementation
        of the
        <interface><ulink url="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/transaction/PlatformTransactionManager.html">PlatformTransactionManager</ulink></interface>
        interface and should be used with a single Rabbit ConnectionFactory.
      </para>
      <important>
        This strategy is not able to provide XA transactions, for example in
        order to share transactions between messaging and database access.
      </important>
      <para>
        Application code is required to retrieve the transactional Rabbit resources
        via <code>ConnectionFactoryUtils.getTransactionalResourceHolder(ConnectionFactory, boolean)</code>
        instead of a standard <code>Connection.createChannel()</code> call with
        subsequent Channel creation. When using Spring's
        <classname><ulink url="http://static.springsource.org/spring-amqp/docs/latest_ga/api/org/springframework/amqp/rabbit/core/RabbitTemplate.html">RabbitTemplate</ulink></classname>,
        it will autodetect a thread-bound Channel and automatically participate
        in it.
      </para>
      <para>
        With Java Configuration you can setup a new RabbitTransactionManager
        using:
      </para>
      <programlisting language="java"><![CDATA[@Bean
public RabbitTransactionManager rabbitTransactionManager() {
    return new RabbitTransactionManager(connectionFactory);
}]]></programlisting>
      <para>
        If you prefer using XML configuration, declare the following bean in your
        XML Application Context file:
      </para>
      <programlisting language="xml"><![CDATA[<bean id="rabbitTxManager"
      class="org.springframework.amqp.rabbit.transaction.RabbitTransactionManager">
    <property name="connectionFactory" ref="connectionFactory"/>
</bean>]]></programlisting>
    </section>
  </section>

  <section id="containerAttributes">
    <title>Message Listener Container Configuration</title>

    <para>There are quite a few options for configuring a
    <classname>SimpleMessageListenerContainer</classname> related to
    transactions and quality of service, and some of them interact with each
    other.</para>

    <para>The table below shows the container property names and their
    equivalent attribute names (in parentheses) when using the namespace to configure a
    <code>&lt;rabbit:message-listener-container/&gt;</code></para>. Some
    properties are not exposed by the namespace; indicated by <code>N/A</code> for
    the attribute.

    <para><table>
        <title>Configuration options for a message listener container</title>

        <tgroup cols="2">
        <colspec colnum="1"  colname="col01" colwidth="2*"/>
        <colspec colnum="2"  colname="col02" colwidth="3*" align="left"/>
          <thead>
            <row>
              <entry><literallayout>Property
(Attribute)</literallayout></entry>
              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literallayout>channelTransacted
(channel-transacted)</literallayout></entry>

              <entry>Boolean flag to signal that all messages should be
              acknowledged in a transaction (either manually or
              automatically)</entry>
            </row>

            <row>
              <entry><literallayout>acknowledgeMode
(acknowledge)</literallayout></entry>

              <entry><literal>NONE</literal> = no acks will be sent
              (incompatible with
              <literal>channelTransacted=true</literal>). RabbitMQ calls this
              "autoack" because the broker assumes all messages are acked
              without any action from the consumer. MANUAL = the listener must
              acknowledge all messages by calling
              <code>Channel.basicAck()</code>. AUTO = the container will
              acknowledge the message automatically, unless the
              <interfacename>MessageListener</interfacename> throws an
              exception. Note that
              <literal>acknowledgeMode</literal> is complementary to
              channelTransacted - if the channel is transacted then the broker
              requires a commit notification in addition to the ack.
              This is the default mode.
              See also <code>txSize</code>.</entry>
            </row>

            <row>
              <entry><literallayout>transactionManager
(transaction-manager)</literallayout></entry>

              <entry>External transaction manager for the operation of the
              listener. Also complementary to channelTransacted - if the
              <classname>Channel</classname> is transacted then its
              transaction will be synchronized with the external
              transaction.</entry>
            </row>

            <row>
              <entry><literallayout>prefetchCount
(prefetch)</literallayout></entry>

              <entry>The number of messages to accept from the broker in one
              socket frame. The higher this is the faster the messages can be
              delivered, but the higher the risk of non-sequential processing.
              Ignored if the <literal>acknowledgeMode</literal> is
              NONE. This will be increased, if necessary, to match the
              <code>txSize</code>.</entry>
            </row>

            <row>
              <entry><literallayout>shutdownTimeout
(N/A)</literallayout></entry>

              <entry>When a container shuts down (e.g. if its enclosing
              <classname>ApplicationContext</classname> is closed) it waits
              for in-flight messages to be processed up to this limit.
              Defaults to 5 seconds. After the limit is reached, if the
              channel is not transacted messages will be discarded.</entry>
            </row>

            <row>
              <entry><literallayout>txSize
(transaction-size)</literallayout></entry>

              <entry>When used with <code>acknowledgeMode</code> AUTO,
              the container will attempt to process up to
              this number of messages before sending an ack (waiting for each one up
              to the receive timeout setting). This is also when a
              transactional channel is committed. If the <code>prefetchCount</code>
              is less than the <code>txSize</code>, it will be increased
              to match the <code>txSize</code>.</entry>
            </row>

            <row>
              <entry><literallayout>receiveTimeout
(receive-timeout)</literallayout></entry>

              <entry>The maximum time to wait for each message. If
              acknowledgeMode=NONE this has very little effect -
              the container just spins round and asks for another message. It
              has the biggest effect for a transactional
              <classname>Channel</classname> with <code>txSize &gt; 1</code>,
              since it can cause messages already consumed not to be
              acknowledged until the timeout expires.</entry>
            </row>

            <row>
              <entry><literallayout>autoStartup
(auto-startup)</literallayout></entry>

              <entry>Flag to indicate that the container should start when the
              <classname>ApplicationContext</classname> does (as part of the
              <classname>SmartLifecycle</classname> callbacks which happen
              after all beans are initialized). Defaults to true, but set it
              to false if your broker might not be available on startup, and
              then call <code>start()</code> later manually when you know the
              broker is ready.</entry>
            </row>

            <row>
              <entry><literallayout>phase
(phase)</literallayout></entry>

              <entry>When autoStartup is true, the lifecycle phase within
              which this container should start and stop. The lower the
              value the earlier this container will start and the later it
              will stop. The default is Integer.MAX_VALUE meaning the
              container will start as late as possible and stop as
              soon as possible.</entry>
            </row>

            <row>
              <entry><literallayout>adviceChain
(advice-chain)</literallayout></entry>

              <entry>An array of AOP Advice to apply to the listener
              execution. This can be used to apply additional cross cutting
              concerns such as automatic retry in the event of broker death.
              Note that simple re-connection after an AMQP error is handled by
              the <classname>CachingConnectionFactory</classname>, as long as
              the broker is still alive.</entry>
            </row>

            <row>
              <entry><literallayout>taskExecutor
(task-executor)</literallayout></entry>

              <entry>A reference to a Spring TaskExecutor (or standard JDK 1.5+
              Executor) for executing listener invokers. Default is a
              SimpleAsyncTaskExecutor, using internally managed threads.</entry>
            </row>

            <row>
              <entry><literallayout>errorHandler
(error-handler)</literallayout></entry>

              <entry>A reference to an ErrorHandler strategy for handling any
              uncaught Exceptions that may occur during the execution of the
              MessageListener.
              Default: <classname>ConditionalRejectingErrorHandler</classname></entry>
            </row>

            <row>
              <entry><literallayout>concurrentConsumers
(concurrency)</literallayout></entry>

              <entry>The number of concurrent consumers to initially start for each
              listener. See <xref linkend="listener-concurrency"/>.</entry>
            </row>

            <row>
              <entry><literallayout>maxConcurrentConsumers
(max-concurrency)</literallayout></entry>

              <entry>The maximum number of concurrent consumers to start, if needed,
              on demand. Must be greater than or equal to 'concurrentConsumers'.
              See <xref linkend="listener-concurrency"/>.</entry>
            </row>

            <row>
              <entry><literallayout>startConsumerMinInterval
(min-start-interval)</literallayout></entry>

              <entry>The time in milliseconds which must elapse before each new consumer
              is started on demand. See <xref linkend="listener-concurrency"/>.
              Default 10000 (10 seconds).</entry>
            </row>

            <row>
              <entry><literallayout>stopConsumerMinInterval
(min-stop-interval)</literallayout></entry>

              <entry>The time in milliseconds which must elapse before a consumer
              is stopped, since the last consumer was stopped, when an idle consumer
              is detected. See <xref linkend="listener-concurrency"/>.
              Default 60000 (1 minute).</entry>
            </row>

            <row>
              <entry><literallayout>consecutiveActiveTrigger
(min-consecutive-active)</literallayout></entry>

              <entry>The minimum number of consecutive messages received by a consumer,
              without a receive timeout occurring, when considering starting a new
              consumer.  Also impacted by 'txSize'.
              See <xref linkend="listener-concurrency"/>. Default 10.</entry>
            </row>

            <row>
              <entry><literallayout>consecutiveIdleTrigger
(min-consecutive-idle)</literallayout></entry>

              <entry>The minimum number of receive timeouts a consumer must experience
              before considering stopping a consumer. Also impacted by 'txSize'.
              See <xref linkend="listener-concurrency"/>. Default 10.
              .</entry>
            </row>

            <row>
              <entry><literallayout>connectionFactory
(connection-factory)</literallayout></entry>

              <entry>A reference to the connectionFactory; when configuring
              using the XML namespace, the default referenced bean name
              is "rabbitConnectionFactory".</entry>
            </row>

            <row>
              <entry><literallayout>defaultRequeueRejected
(requeue-rejected)</literallayout></entry>

              <entry>Determines whether messages that are
              rejected because the listener
              threw an exception should be requeued or not. Default 'true'.</entry>
            </row>

            <row>
              <entry><literallayout>recoveryInterval
(recovery-interval)</literallayout></entry>

              <entry>Determines the time in milliseconds between attempts to start a consumer
              if it fails to start for non-fatal reasons. Default '5000'.</entry>
            </row>

            <row>
              <entry><literallayout>exclusive
(exclusive)</literallayout></entry>

              <entry>Determines whether the single consumer in this container has
              exclusive access to the queue(s). The concurrency of the container
              must be 1 when this is true. If another consumer has exclusive access,
              the container will attempt to recover the consumer, according to the
              <code>recovery-interval</code>. When using the namespace, this attribute
              appears on the &lt;rabbit:listener/&gt; element along with the queue names.
              Default 'false'.</entry>
            </row>
            <row>
              <entry><literallayout>rabbitAdmin
(admin)</literallayout></entry>

              <entry>When a listener container listens to at least one auto-delete
              queue and it is found to be missing during startup, the container uses
              a <classname>RabbitAdmin</classname> to declare the queue and any
              related bindings and exchanges. If such elements are configured to
              use conditional declaration (see <xref linkend="conditional-declaration"/>),
              the container must use the admin that was configured to declare those
              elements. Specify that admin here; only required when using auto-delete
              queues with conditional declaration. If you do not wish the auto-delete
              queue(s) to be declared until the container is started, set
              <code>auto-startup</code> to <code>false</code> on the admin.
              Defaults to a <classname>RabbitAdmin</classname> that
              will declare all non-conditional elements.</entry>
            </row>
            <row>
              <entry><literallayout>missingQueuesFatal
(missing-queues-fatal)</literallayout></entry>

              <entry><para>Starting with <emphasis>version 1.3.5</emphasis>,
              <classname>SimpleMessageListenerContainer</classname> has this new
              property.</para>
              <para>When set to <code>true</code> (default), if none of the configured
              queues are available on the broker, it is considered fatal. This causes
              the application context to fail to initialize during startup; also, when the queues
              are deleted while the container is running, the consumers make 3 attempts
              to connect to the queues (at 5 second intervals) and stop the container
              if these attempts fail.</para>
              <para>This was not configurable in previous versions.</para>
              <para>When set to <code>false</code>, after making the 3 attempts, the container
              will go into recovery mode, as with other problems, such as the broker being
              down. The container will attempt to recover according to the <code>recoveryInterval</code>
              property. During each recovery attempt, each consumer will again try 3 times
              to passively declare the queues at 5 second intervals. This process will
              continue indefinitely.</para>
              <para>You can also use a properties bean to set the property
              globally for all containers, as follows:</para>
              <programlisting language="xml"><![CDATA[<util:properties id="spring.amqp.global.properties">
    <prop key="smlc.missing.queues.fatal">false</prop>
</util:properties>]]></programlisting>
              <para>This global property will not be applied to any containers that have an explicit
              <code>missingQueuesFatal</code> property set.</para>
              </entry>
            </row>
			  <row>
				  <entry><literallayout>autoDeclare (auto-declare)</literallayout></entry>

				  <entry><para>Starting with <emphasis>version 1.4</emphasis>,
					  <classname>SimpleMessageListenerContainer</classname> has this new
					  property.</para>
					  <para>When set to <code>true</code> (default), a the container will redeclare all AMQP objects
						  (Queues, Exchanges, Bindings), if it detects that at least one of its queues is
						  missing during startup, perhaps because it's an
						  <code>auto-delete</code> or an expired queue, but the redeclaration will
						  proceed if the queue is missing for any reason.
						  To disable this behavior, set this property to <code>false</code>. Note that the
						  container will fail to start if all of its queues are missing.
					</para>
				  </entry>
			  </row>
          </tbody>
        </tgroup>
      </table></para>
  </section>

  <section id="listener-concurrency">
    <title>Listener Concurrency</title>

    <para>
      By default, the listener container will start a single consumer which
      will receive messages from the queue(s).
    </para>
    <para>
      When examining the table in the previous section, you will see a number
      of properties/attributes that control concurrency. The simplest is
      <code>concurrentConsumers</code>, which simply creates that (fixed) number
      of consumers which will concurrently process messages.
    </para>
    <para>
      Prior to <emphasis>version 1.3.0</emphasis>, this was the only setting available
      and the container had to be stopped and started again to change the setting.
    </para>
    <para>
      Since <emphasis>version 1.3.0</emphasis>, you can now dynamically
      adjust the <code>concurrentConsumers</code> property. If it is
      changed while the container is running, consumers will be added or
      removed as necessary to adjust to the new setting.
    </para>
    <para>
      In addition, a new property <code>maxConcurrentConsumers</code> has been
      added and the container will dynamically adjust the concurrency based on
      workload. This works in conjunction with four additional properties:
      <code>consecutiveActiveTrigger</code>, <code>startConsumerMinInterval</code>,
      <code>consecutiveIdleTrigger</code>, <code>stopConsumerMinInterval</code>. With
      the default settings, the algorithm to increase consumers works as follows:
    </para>
    <para>
      If the <code>maxConcurrentConsumers</code> has not been reached and an existing
      consumer is active for 10 consecutive cycles AND at least 10 seconds
      has elapsed since the last consumer was started, a new consumer is started.
      A consumer is considered active if it received at least one message in
      <code>txSize</code> * <code>receiveTimeout</code> milliseconds.
    </para>
    <para>
      With the default settings, the algorithm to decrease consumers works as follows:
    </para>
    <para>
      If there are more than <code>concurrentConsumers</code> running and a consumer
      detects 10 consecutive timeouts (idle) AND the last consumer was stopped at
      least 60 seconds ago, a consumer will be stopped. The timeout depends on the
      <code>receiveTimeout</code> and the <code>txSize</code> properties. A consumer
      is considered idle if it receives no messages in <code>txSize</code> *
      <code>receiveTimeout</code> milliseconds. So, with the
      default timeout (1 second) and a <code>txSize</code> of 4, stopping a consumer
      will be considered after 40 seconds of idle time (4 timeouts correspond to 1
      idle detection).
    </para>
    <note>
      Practically, consumers will only be stopped if the whole container is idle for
      some time. This is because the broker will share its work across all the active
      consumers.
    </note>
  </section>

  <section id="exclusive-consumer">
    <title>Exclusive Consumer</title>
    <para>
       Also starting with <emphasis>version 1.3</emphasis>, the listener container can
       be configured with a single exclusive consumer; this prevents other containers
       from consuming from the queue(s) until the current consumer is cancelled. The
       concurrency of such a container must be 1.
    </para>
    <para>
       When using exclusive consumers, other containers will attempt to consume from
       the queue(s) according to the <code>recoveryInterval</code> property, and log
       a WARNing if the attempt fails.
    </para>
  </section>

  <section id="listener-queues">
    <title>Listener Container Queues</title>
    <para>
      <emphasis>Version 1.3</emphasis> introduced a number of improvements
      for handling multiple queues in a listener container.
    </para>
    <para>
      The container must be configured to listen on at least one queue; this
      was the case previously too, but now
      queues can be added and removed at runtime.
      The container will recycle (cancel and re-create) the consumers when any
      pre-fetched messages have been processed. See methods <code>addQueues</code>,
      <code>addQueueNames</code>, <code>removeQueues</code> and
      <code>removeQueueNames</code>. When removing queues,
      at least one queue must remain.
    </para>
    <para>
      A consumer will now start if any of its queues are available - previously the
      container would stop if any queues were unavailable. Now, this is only the case
      if none of the queues are available. If not all queues are available, the
      container will attempt to passively declare (and consume from) the missing
      queue(s) every 60 seconds.
    </para>
    <para>
      Also, if a consumer receives a cancel from the broker (for example if a queue
      is deleted) the consumer will attempt to recover and the recovered consumer
      will continue to process messages from any other configured
      queues. Previously a cancel on one queue cancelled the entire consumer and
      eventually the container would stop due to the missing queue.
    </para>
    <para>
      If you wish to permanently remove a queue, you should update the container
      before or after deleting to queue, to avoid future attempts to consume
      from it.
    </para>
  </section>

  <section>
    <title>Resilience: Recovering from Errors and Broker Failures</title>

    <para>Some of the key (and most popular) high-level features that
    Spring AMQP provides are to do with recovery and automatic
    re-connection in the event of a protocol error or broker failure.
    We have seen all the relevant components already in this guide,
    but it should help to bring them all together here and call out
    the features and recovery scenarios individually.</para>

    <para>The primary reconnection features are enabled by the
    <classname>CachingConnectionFactory</classname> itself.
    It is also often beneficial to use the <classname>RabbitAdmin</classname>
    auto-declaration features. In addition, if you care about
    guaranteed delivery, you probably also need to use the
    <code>channelTransacted</code> flag in
    <classname>RabbitTemplate</classname> and
    <classname>SimpleMessageListenerContainer</classname> and also the
    <code>AcknowledgeMode.AUTO</code> (or manual if you do the acks
    yourself) in the
    <classname>SimpleMessageListenerContainer</classname>.</para>

    <section id="automatic-declaration">
      <title>Automatic Declaration of Exchanges, Queues and
      Bindings</title>

      <para>The <classname>RabbitAdmin</classname> component can
      declare exchanges, queues and bindings on startup.  It does this
      lazily, through a <classname>ConnectionListener</classname>, so
      if the broker is not present on startup it doesn't matter.  The
      first time a <classname>Connection</classname> is used (e.g. by
      sending a message) the listener will fire and the admin features
      will be applied.  A further benefit of doing the auto
      declarations in a listener is that if the connection is dropped
      for any reason (e.g. broker death, network glitch, etc.) they
      will be applied again the next time they are needed.</para>

	  <note>
		Queues declared this way must have fixed names; either explicitly
		declared, or generated by the framework for <classname>AnonymousQueue</classname>s.
		Anonymous queues are non-durable, exclusive, and auto-delete.
	  </note>
	  <important>
		Automatic declaration is only performed when the
		<classname>CachingConnectionFactory</classname> cache mode
		is <code>CHANNEL</code> (the default). This limitation exists
		because exlusive and auto-delete queues are bound to the
		connection.
	  </important>
    </section>

    <section id="retry">
      <title>Failures in Synchronous Operations and Options for Retry</title>

      <para>If you lose your connection to the broker in a synchronous
      sequence using <classname>RabbitTemplate</classname> (for
      instance), then Spring AMQP will throw an
      <classname>AmqpException</classname> (usually but not always
      <classname>AmqpIOException</classname>).  We don't try to hide
      the fact that there was a problem, so you have to be able to
      catch and respond to the exception.  The easiest thing to do if
      you suspect that the connection was lost, and it wasn't your
      fault, is to simply try the operation again.  You can do this
      manually, or you could look at using Spring Retry to handle the
      retry (imperatively or declaratively).</para>

      <para>Spring Retry provides a couple of AOP interceptors and a
      great deal of flexibility to specify the parameters of the retry
      (number of attempts, exception types, backoff algorithm etc.).
      Spring AMQP also provides some convenience factory beans for
      creating Spring Retry interceptors in a convenient form for AMQP
      use cases, with strongly typed callback interfaces for you to
      implement custom recovery logic.  See the Javadocs and
      properties of
      <classname>StatefulRetryOperationsInterceptor</classname> and
      <classname>StatelessRetryOperationsInterceptor</classname> for
      more detail.  Stateless retry is appropriate if there is no
      transaction or if a transaction is started inside the retry
      callback.  Note that stateless retry is simpler to configure and
      analyse than stateful retry, but it is not usually appropriate
      if there is an ongoing transaction which must be rolled back or
      definitely is going to roll back.  A dropped connection in the
      middle of a transaction should have the same effect as a
      rollback, so for reconnection where the transaction is started
      higher up the stack, stateful retry is usually the best
      choice.</para>

		<para>
			Starting with <emphasis>version 1.3</emphasis>, a builder API
			is provided to aid in assembling these interceptors using
			Java (or in <code>@Configuration</code> classes), for example:
		</para>
		<programlisting language="java"><![CDATA[@Bean
public StatefulRetryOperationsInterceptor interceptor() {
	return RetryInterceptorBuilder.stateful()
			.maxAttempts(5)
			.backOffOptions(1000, 2.0, 10000) // initialInterval, multiplier, maxInterval
			.build();
}]]></programlisting>
	<para>
		Only a subset of retry capabilities can be configured this way; more advanced
		features would need the configuration of a <classname>RetryTemplate</classname>
		as a Spring bean.
		See the <ulink url="http://static.springsource.org/spring-retry/docs/api/current/"
		>Spring Retry Javadocs</ulink> for complete information about available policies
		and their configuration.
	</para>
    </section>

    <section id="async-listeners">
      <title>Message Listeners and the Asynchronous Case</title>

      <para>If a <classname>MessageListener</classname> fails because
      of a business exception, the exception is handled by the message
      listener container and then it goes back to listening for
      another message.  If the failure is caused by a dropped
      connection (not a business exception), then the consumer that is
      collecting messages for the listener has to be cancelled and
      restarted.  The
      <classname>SimpleMessageListenerContainer</classname> handles
      this seamlessly, and it leaves a log to say that the listener is
      being restarted.  In fact it loops endlessly trying to restart
      the consumer, and only if the consumer is very badly behaved
      indeed will it give up.  One side effect is that if the broker
      is down when the container starts, it will just keep trying
      until a connection can be established.</para>

      <para>Business exception handling, as opposed to protocol errors
      and dropped connections, might need more thought and some custom
      configuration, especially if transactions and/or container acks
      are in use.  Prior to 2.8.x, RabbitMQ had no definition of dead letter behaviour, so
      by default a message that is rejected or rolled back because of
      a business exception can be redelivered ad infinitum.  To put a
      limit in the client on the number of re-deliveries, one
      choice is a
      <classname>StatefulRetryOperationsInterceptor</classname> in the
      advice chain of the listener.  The interceptor can have a
      recovery callback that implements a custom dead letter action:
      whatever is appropriate for your particular environment.</para>

      <para>Another alternative is to set the container's rejectRequeued
      property to false. This causes all failed messages to be discarded.
      When using RabbitMQ 2.8.x or higher, this also facilitates
      delivering the message to a Dead Letter Exchange.</para>

      <para>Or, you can throw a <classname>AmqpRejectAndDontRequeueException</classname>;
      this prevents message requeuing, regardless of the setting of the
      <code>defaultRequeueRejected</code> property.</para>

      <para>Often, a combination of both techniques will be used. Use a
      <classname>StatefulRetryOperationsInterceptor</classname> in the
      advice chain, where it's <classname>MessageRecover</classname>
      throws an <classname>AmqpRejectAndDontRequeueException</classname>.
      The <classname>MessageRecover</classname> is called when all
      retries have been exhausted. The default
      <classname>MessageRecoverer</classname> simply consumes the
      errant message and emits a WARN message. In which case,
      the message is ACK'd and won't be sent to the Dead Letter
      Exchange, if any.</para>

	  <para>Starting with <emphasis>version 1.3</emphasis>, a new
	  <classname>RepublishMessageRecoverer</classname> is provided,
	  to allow publishing of failed messages after retries are exhausted:</para>
	  <programlisting language="java"><![CDATA[@Bean
RetryOperationsInterceptor interceptor() {
	return RetryInterceptorBuilder.stateless()
			.withMaxAttempts(5)
			.setRecoverer(new RepublishMessageRecoverer(amqpTemplate(), "bar", "baz"))
			.build();
}]]></programlisting>

      <para></para>
    </section>

    <section>
      <title>Exception Classification for Retry</title>
	</section>
	<para>
		Spring Retry has a great deal of flexibility for determining which
		exceptions can invoke retry. The default configuration will retry
		for all exceptions. Given that user exceptions will be wrapped in
		a <classname>ListenerExecutionFailedException</classname> we need
		to ensure that the classification examines the exception causes.
		The default classifier just looks at the top level exception.
	</para>
	<para>
		Since <emphasis>Spring Retry 1.0.3</emphasis>, the
		<classname>BinaryExceptionClassifier</classname> has a property
		<code>traverseCauses</code> (default <code>false</code>). When
		<code>true</code> it will traverse exception causes until it
		finds a match or there is no cause.
	</para>
	<para>
		To use this classifier for retry, use a <classname>SimpleRetryPolicy</classname>
		created with the constructor that takes the max attempts, the
		<interfacename>Map</interfacename> of <classname>Exception</classname>s
		and the boolean (traverseCauses), and inject this policy into the
		<classname>RetryTemplate</classname>.
	</para>
  </section>

  <section>
	<title>Debugging</title>
	<para>
		Spring AMQP provides extensive logging, especially at <code>DEBUG</code> level.
	</para>
	<para>
		If you wish to monitor the AMQP protocol between the application and broker, you could
		use a tool such as WireShark, which has a plugin to decode the protocol. Alternatively
		the RabbitMQ java client comes with a very useful class <classname>Tracer</classname>.
		When run as a <code>main</code>, by default, it listens on port 5673 and connects
		to port 5672 on localhost. Simply run it, and change your connection factory
		configuration to connect to port 5673 on localhost. It displays the decoded protocol
		on the console. Refer to the <classname>Tracer</classname> javadocs for more information.
	</para>
  </section>

</chapter>
