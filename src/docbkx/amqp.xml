<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="amqp">
  <title>Using Spring AMQP</title>

  <para>In this chapter, we will explore the interfaces and classes that are the
  essential components for developing applications with Spring AMQP.</para>

  <section>
    <title>AMQP Abstractions</title>

    <para>Spring AMQP consists of a handful of modules, each represented by a
    JAR in the distribution. These modules are: spring-amqp, spring-rabbit and
    spring-erlang. The 'spring-amqp' module contains the
    <literal>org.springframework.amqp.core</literal> package. Within that
    package, you will find the classes that represent the core AMQP "model".
    Our intention is to provide generic abstractions that do not rely on any
    particular AMQP broker implementation or client library. End user code
    will be more portable across vendor implementations as it can be developed
    against the abstraction layer only. These abstractions are then used
    implemented by broker-specific modules, such as 'spring-rabbit'. For the
    1.0 release there is only a RabbitMQ implementation however the
    abstractions have been validated in .NET using Apache Qpid in addition to
    RabbitMQ. Since AMQP operates at the protocol level in principle the
    RabbitMQ client can be used with any broker that supports the same
    protocol version, but we do not test any other brokers at present.</para>

    <para>The overview here assumes that you are already familiar with the
    basics of the AMQP specification already. If you are not, then have a look
    at the resources listed in <xref linkend="resources" /></para>

    <sect2>
      <title>Message</title>

      <para>The 0-8 and 0-9-1 AMQP specifications do not define a Message
      class or interface. Instead, when performing an operation such as
      '<literal>
          <methodname>basicPublish</methodname>
        </literal>', the content is passed as a byte-array argument and
      additional properties are passed in as separate arguments. Spring AMQP
      defines a Message class as part of a more general AMQP domain model
      representation. The purpose of the Message class is to simply
      encapsulate the body and properties within a single instance so that the
      API can in turn be simpler. The Message class definition is quite
      straightforward.</para>

      <programlisting language="java"><![CDATA[public class Message {

    private final MessageProperties messageProperties;

    private final byte[] body;

    public Message(byte[] body, MessageProperties messageProperties) {
        this.body = body;
        this.messageProperties = messageProperties;
    }

    public byte[] getBody() {
        return this.body;
    }

    public MessageProperties getMessageProperties() {
        return this.messageProperties;
}]]></programlisting>

      <para>The <interfacename>MessageProperties</interfacename> interface
      defines several common properties such as 'messageId', 'timestamp',
      'contentType', and several more. Those properties can also be extended
      with user-defined 'headers' by calling the <methodname>setHeader(String
      key, Object value)</methodname> method.</para>
    </sect2>

    <sect2>
      <title>Exchange</title>

      <para>The <interfacename>Exchange</interfacename> interface represents
      an AMQP Exchange, which is what a Message Producer sends to. Each
      Exchange within a virtual host of a broker will have a unique name as
      well as a few other properties:</para>

      <programlisting language="java"><![CDATA[public interface Exchange {

    String getName();

    ExchangeType getExchangeType();

    boolean isDurable();

    boolean isAutoDelete();

    Map<String, Object> getArguments();

}]]></programlisting>

      <para>As you can see, an Exchange also has a 'type' represented by the
      enumeration <classname>ExchangeType</classname>. The basic types are:
      <literal>Direct</literal>, <literal>Topic</literal> and
      <literal>Fanout</literal>. In the core package you will find
      implementations of the <interfacename>Exchange</interfacename> interface
      for each of those types. The behavior varies across these Exchange types
      in terms of how they handle bindings to Queues. A Direct exchange allows
      for a Queue to be bound by a fixed routing key (often the Queue's name).
      A Topic exchange supports bindings with routing patterns that may
      include the '*' and '#' wildcards for 'exactly-one' and 'zero-or-more',
      respectively. The Fanout exchange publishes to all Queues that are bound
      to it without taking any routing key into consideration. For much more
      information about Exchange types, check out <xref
      linkend="resources" />.</para>

      <note>
        <para>The AMQP specification also requires that any broker provide a
        "default" Direct Exchange that has no name. All Queues that are
        declared will be bound to that default Exchange with their names as
        routing keys. You will learn more about the default Exchange's usage
        within Spring AMQP in <xref linkend="amqp-template" />.</para>
      </note>
    </sect2>

    <sect2>
      <title>Queue</title>

      <para>The <classname>Queue</classname> class represents the component
      from which a Message Consumer receives Messages. Like the various
      Exchange classes, our implementation is intended to be an abstract
      representation of this core AMQP type.</para>

      <programlisting language="java"><![CDATA[public class Queue  {

    private final String name;

    private volatile boolean durable;

    private volatile boolean exclusive;

    private volatile boolean autoDelete;

    private volatile Map<String, Object> arguments;

    /**
     * The queue is durable, non-exclusive and non auto-delete.
     * 
     * @param name the name of the queue.
     */
    public Queue(String name) {
        this(name, true, false, false);
    }

    // Getters and Setters omitted for brevity

]]></programlisting>

      <para>Notice that the constructor takes the Queue name. Depending on the
      implementation, the admin template may provide methods for generating a
      uniquely named Queue. Such Queues can be useful as a "reply-to" address
      or other <emphasis>temporary</emphasis> situations. For that reason, the
      'exclusive' and 'autoDelete' properties of an auto-generated Queue would
      both be set to 'true'.</para>
    </sect2>

    <sect2>
      <title>Binding</title>

      <para>Given that a producer sends to an Exchange and a consumer receives
      from a Queue, the bindings that connect Queues to Exchanges are critical
      for connecting those producers and consumers via messaging. In Spring
      AMQP, we define a <classname>Binding</classname> class to represent
      those connections. Let's review the basic options for binding Queues to
      Exchanges.</para>

      <para>You can bind a Queue to a DirectExchange with a fixed routing
      key.</para>

      <programlisting language="java"><![CDATA[new Binding(someQueue, someDirectExchange, "foo.bar")]]></programlisting>

      <para>You can bind a Queue to a TopicExchange with a routing
      pattern.</para>

      <programlisting language="java"><![CDATA[new Binding(someQueue, someTopicExchange, "foo.*")]]></programlisting>

      <para>You can bind a Queue to a FanoutExchange with no routing
      key.</para>

      <programlisting language="java"><![CDATA[new Binding(someQueue, someFanoutExchange)]]></programlisting>

      <para>We also provide a <classname>BindingBuilder</classname> to
      facilitate a "fluent API" style.</para>

      <programlisting language="java"><![CDATA[Binding b = BindingBuilder.bind(someQueue).to(someTopicExchange).with("foo.*");]]></programlisting>

      <note>
        <para>The BindingBuilder class is shown above for clarity, but this
        style works well when using a static import for the 'bind()'
        method.</para>
      </note>

      <para>By itself, an instance of the Binding class is just holding the
      data about a connection. In other words, it is not an "active"
      component. However, as you will see later in <xref
      linkend="broker-configuration" />, Binding instances can be used by the
      <interfacename>AmqpAdmin</interfacename> class to actually trigger the
      binding actions on the broker. Also, as you will see in that same
      section, the Binding instances can be defined using Spring's
      <literal>@Bean</literal>-style within <literal>@Configuration</literal>
      classes. There is also a convenient base class which further simplifies
      that approach for generating AMQP-related bean definitions and
      recognizes the Queues, Exchanges, and Bindings so that they will all be
      declared on the AMQP broker upon application startup.</para>
    </sect2>

    <para>The <interfacename>AmqpTemplate</interfacename> is also defined
    within the core package. As one of the main components involved in actual
    AMQP messaging, it is discussed in detail in its own section (see <xref
    linkend="amqp-template" />).</para>
  </section>

  <section>
    <title>Connection and Resource Management</title>

    <para>Whereas the AMQP model we described in the previous section is
    generic and applicable to all implementations, when we get into the
    management of resources, the details are specific to the broker
    implementation. Therefore, in this section, we will be focusing on code
    that exists only within our "spring-rabbit" module since at this point,
    RabbitMQ is the only supported implementation.</para>

    <para>The central component for managing a connection to the
    RabbitMQ broker is the
    <interfacename>ConnectionFactory</interfacename> interface.  The
    responsibility of a
    <interfacename>ConnectionFactory</interfacename> implementation is
    to provide an instance of
    <classname>org.springframework.amqp.rabbit.connection.Connection</classname>
    which is a wrapper for
    <classname>com.rabbitmq.client.Connection</classname>. The
    only concrete implementation we provide is
    <classname>CachingConnectionFactory</classname> which establishes a
    single connection proxy that can be shared by the application. Sharing
    of the connection is possible since the "unit of work" for
    messaging with AMQP is actually a "channel" (in some ways, this is
    similar to the relationship between a Connection and a Session in
    JMS). As you can imagine, the connection instance provides a
    <methodname>createChannel</methodname> method. The
    <classname>CachingConnectionFactory</classname> implementation
    supports caching of those channels, and it maintains separate
    caches for channels based on whether they are transactional or not.
    When creating an instance of <classname>CachingConnectionFactory</classname>,
    the 'hostname' can be provided via the constructor. The 'username' and
    'password' properties should be provided as well. If you would like to
    configure the size of the channel cache (the default is 1), you could
    call the <methodname>setChannelCacheSize()</methodname> method here as well.</para>

    <programlisting language="java"><![CDATA[CachingConnectionFactory connectionFactory = new CachingConnectionFactory("somehost");
connectionFactory.setUsername("guest");
connectionFactory.setPassword("guest");

Connection connection = connectionFactory.createConnection();]]></programlisting>

    <para>When using XML, the configuration might look like this:</para>

    <programlisting language="xml"><![CDATA[<bean id="connectionFactory"
      class="org.springframework.amqp.rabbit.connection.CachingConnectionFactory">
    <constructor-arg value="somehost"/>
    <property name="username" value="guest"/>
    <property name="password" value="guest"/>
</bean>]]></programlisting>

    <para><note> There is also a <classname>SingleConnectionFactory</classname>
    implementation which is only available in the unit test code of the framework.
    It is simpler than <classname>CachingConnectionFactory</classname> since it does
    not cache channels, but it is not intended for practical usage
    outside of simple tests due to its lack of performance and resilience.
    If you find a need to implement your own <classname>ConnectionFactory</classname>
    for some reason, the <classname>AbstractConnectionFactory</classname>
    base class may provide a nice starting point.</note>

    A <classname>ConnectionFactory</classname> can
    be created quickly and conveniently using the rabbit namespace:
    <programlisting language="xml"><![CDATA[<rabbit:connection-factory
    id="connectionFactory"/>]]></programlisting> In most cases this
    will be preferable since the framework can choose the best
    defaults for you. The created instance will be a
    <classname>CachingConnectionFactory</classname>.

    Keep in mind that the default cache size for channels is 1.
    If you want more channels to be cached set a larger value via the
    'channelCacheSize' property. In XML it would look like this:
    <programlisting language="xml"><![CDATA[<bean id="connectionFactory"
      class="org.springframework.amqp.rabbit.connection.CachingConnectionFactory">
    <constructor-arg value="somehost"/>
    <property name="username" value="guest"/>
    <property name="password" value="guest"/>
    <property name="channelCacheSize" value="25"/>
</bean>]]></programlisting>
    And with the namespace you can just add the 'channel-cache-size' attribute:
    <programlisting language="xml"><![CDATA[<rabbit:connection-factory
    id="connectionFactory" channel-cache-size="25"/>]]></programlisting>
    </para>
    <para>
    Host and port attributes can be provided using the namespace
    <programlisting language="xml"><![CDATA[<rabbit:connection-factory
    id="connectionFactory" host="somehost" port="5672" />]]></programlisting>
    </para>
    <para>
	Alternatively, if running in a clustered environment, use the addresses
	attribute.
    <programlisting language="xml"><![CDATA[<rabbit:connection-factory
    id="connectionFactory" addresses="host1:5672,host2:5672" />]]></programlisting>
    </para>
  </section>

  <section id="amqp-template">
    <title>AmqpTemplate</title>

    <para>As with many other high-level abstractions provided by the Spring
    Framework and related projects, Spring AMQP provides a "template" that
    plays a central role. The interface that defines the main operations is
    called <interfacename>AmqpTemplate</interfacename>. Those operations cover
    the general behavior for sending and receiving Messages. In other words,
    they are not unique to any implementation, hence the "AMQP" in the name.
    On the other hand, there are implementations of that interface that are
    tied to implementations of the AMQP protocol. Unlike JMS, which is an
    interface-level API itself, AMQP is a wire-level protocol. The
    implementations of that protocol provide their own client libraries, so
    each implementation of the template interface will depend on a particular
    client library. Currently, there is only a single implementation:
    <classname>RabbitTemplate</classname>. In the examples that follow, you
    will often see usage of an "AmqpTemplate", but when you look at the
    configuration examples, or any code excerpts where the template is
    instantiated and/or setters are invoked, you will see the implementation
    type (e.g. "RabbitTemplate").</para>

    <para>As mentioned above, the <interfacename>AmqpTemplate</interfacename>
    interface defines all of the basic operations for sending and receiving
    Messages. We will explore Message sending and reception, respectively, in
    the two sections that follow.</para>
  </section>

  <section>
    <title>Sending messages</title>

    <para>When sending a Message, one can use any of the following
    methods:</para>

    <programlisting language="xml"><![CDATA[void send(Message message) throws AmqpException;

void send(String routingKey, Message message) throws AmqpException;

void send(String exchange, String routingKey, Message message) throws AmqpException;]]></programlisting>

    <para>We can begin our discussion with the last method listed above since
    it is actually the most explicit. It allows an AMQP Exchange name to be
    provided at runtime along with a routing key. The last parameter is the
    callback that is responsible for actual creating of the Message instance.
    An example of using this method to send a Message might look this
    this:</para>

    <programlisting language="java"><![CDATA[amqpTemplate.send("marketData.topic", "quotes.nasdaq.FOO", new Message("12.34".getBytes(), someProperties));]]></programlisting>

    <para>The "exchange" property can be set on the template itself if you
    plan to use that template instance to send to the same exchange most or
    all of the time. In such cases, the second method listed above may be used
    instead. The following example is functionally equivalent to the previous
    one:</para>

    <programlisting language="java"><![CDATA[amqpTemplate.setExchange("marketData.topic");
amqpTemplate.send("quotes.nasdaq.FOO", new Message("12.34".getBytes(), someProperties));]]></programlisting>

    <para>If both the "exchange" and "routingKey" properties are set on the
    template, then the method accepting only the
    <interfacename>Message</interfacename> may be used:</para>

    <programlisting language="java"><![CDATA[amqpTemplate.setExchange("marketData.topic");
amqpTemplate.setRoutingKey("quotes.nasdaq.FOO");
amqpTemplate.send(new Message("12.34".getBytes(), someProperties));]]></programlisting>

    <para>A better way of thinking about the exchange and routing key
    properties is that the explicit method parameters will always override the
    template's default values. In fact, even if you do not explicitly set
    those properties on the template, there are always default values in
    place. In both cases, the default is an empty String, but that is actually
    a sensible default. As far as the routing key is concerned, it's not
    always necessary in the first place (e.g. a Fanout Exchange). Furthermore,
    a Queue may be bound to an Exchange with an empty String. Those are both
    legitimate scenarios for reliance on the default empty String value for
    the routing key property of the template. As far as the Exchange name is
    concerned, the empty String is quite commonly used because the AMQP
    specification defines the "default Exchange" as having no name. Since all
    Queues are automatically bound to that default Exchange (which is a Direct
    Exchange) using their name as the binding value, that second method above
    can be used for simple point-to-point Messaging to any Queue through the
    default Exchange. Simply provide the queue name as the "routingKey" -
    either by providing the method parameter at runtime:</para>

    <programlisting language="java"><![CDATA[RabbitTemplate template = new RabbitTemplate(); // using default no-name Exchange
template.send("queue.helloWorld", new Message("Hello World".getBytes(), someProperties));]]></programlisting>

    <para>Or, if you prefer to create a template that will be used for
    publishing primarily or exclusively to a single Queue, the following is
    perfectly reasonable:</para>

    <programlisting language="java"><![CDATA[RabbitTemplate template = new RabbitTemplate(); // using default no-name Exchange
template.setRoutingKey("queue.helloWorld"); // but we'll always send to this Queue
template.send(new Message("Hello World".getBytes(), someProperties));]]></programlisting>

    <para></para>
  </section>

  <section>
    <title>Receiving messages</title>

    <para>Message reception is always a bit more complicated than sending. The
    reason is that there are two ways to receive a
    <classname>Message</classname>. The simpler option is to poll for a single
    <classname>Message</classname> at a time with a synchronous, blocking
    method call. The more complicated yet more common approach is to register
    a listener that will receive <classname>Messages</classname> on-demand,
    asynchronously. We will look at an example of each approach in the next
    two sub-sections.</para>

    <sect2>
      <title>Synchronous Consumer</title>

      <para>The <interfacename>AmqpTemplate</interfacename> itself can be used
      for synchronous Message reception. There are two 'receive' methods
      available. As with the Exchange on the sending side, there is a method
      that requires a queue property having been set directly on the template
      itself, and there is a method that accepts a queue parameter at
      runtime.</para>

      <programlisting language="java"><![CDATA[Message receive() throws AmqpException;

Message receive(String queueName) throws AmqpException;]]></programlisting>

      <para>Just like in the case of sending messages, the
      <classname>AmqpTemplate</classname> has some convenience methods for
      receiving POJOs instead of <classname>Message</classname> instances, and
      implementations will provide a way to customize the
      <classname>MessageConverter</classname> used to create the
      <classname>Object</classname> returned:</para>

      <para>
        <programlisting><![CDATA[Object receiveAndConvert() throws AmqpException;

Object receiveAndConvert(String queueName) throws AmqpException;]]></programlisting>
      </para>
    </sect2>

    <sect2><title>Asynchronous Consumer</title><para>For asynchronous Message
    reception, a dedicated component (not the
    <interfacename>AmqpTemplate</interfacename>) is involved. That component
    is a container for a Message consuming callback. We will look at the
    container and its properties in just a moment, but first we should look at
    the callback since that is where your application code will be integrated
    with the messaging system. There are a few options for the callback. The
    simplest of these is to implement the
    <interfacename>MessageListener</interfacename> interface:</para>
    <programlisting language="java"><![CDATA[public interface MessageListener {

    void onMessage(Message message);

}]]></programlisting> <para>If your callback logic depends upon the AMQP
    Channel instance for any reason, you may instead use the
    <interfacename>ChannelAwareMessageListener</interfacename>. It looks
    similar but with an extra parameter:</para> <programlisting
    language="java"><![CDATA[public interface ChannelAwareMessageListener {

    void onMessage(Message message, Channel channel) throws Exception;

}]]></programlisting> <para>If you prefer to maintain a stricter separation
    between your application logic and the messaging API, you can rely upon an
    adapter implementation that is provided by the framework. This is often
    referred to as "Message-driven POJO" support. When using the adapter, you
    only need to provide a reference to the instance that the adapter itself
    should invoke.</para><programlisting language="java"><![CDATA[MessageListener listener = new MessageListenerAdapter(somePojo);]]></programlisting>Now
    that you've seen the various options for the Message-listening callback,
    we can turn our attention to the container. Basically, the container
    handles the "active" responsibilities so that the listener callback can
    remain passive. The container is an example of a "lifecycle" component. It
    provides methods for starting and stopping. When configuring the
    container, you are essentially bridging the gap between an AMQP Queue and
    the <interfacename>MessageListener</interfacename> instance. You must
    provide a reference to the
    <interfacename>ConnectionFactory</interfacename> and the queue name or
    Queue instance(s) from which that listener should consume Messages. Here
    is the most basic example using the default implementation,
    <classname>SimpleMessageListenerContainer</classname> : <programlisting
    language="java"><![CDATA[SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
container.setConnectionFactory(rabbitConnectionFactory);
container.setQueueNames("some.queue");
container.setMessageListener(new MessageListenerAdapter(somePojo));]]></programlisting>
    As an "active" component, it's most common to create the listener
    container with a bean definition so that it can simply run in the
    background. This can be done via XML: <programlisting language="xml"><![CDATA[<rabbit:listener-container connection-factory="rabbitConnectionFactory">
    <rabbit:listener queues="some.queue" ref="somePojo" method="handle"/>
</rabbit:listener-container>]]></programlisting> Or, you may prefer to use the
    @Configuration style which will look very similar to the actual code
    snippet above: <programlisting language="java"><![CDATA[@Configuration
public class ExampleAmqpConfiguration {

    @Bean
    public MessageListenerContainer messageListenerContainer() {
        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
        container.setConnectionFactory(rabbitConnectionFactory());
        container.setQueueName("some.queue");
        container.setMessageListener(exampleListener());
        return container;
    }

    @Bean
    public ConnectionFactory rabbitConnectionFactory() {
        CachingConnectionFactory connectionFactory = new CachingConnectionFactory("localhost");
        connectionFactory.setUsername("guest");
        connectionFactory.setPassword("guest");
        return connectionFactory;
    }

    @Bean
    public MessageListener exampleListener() {
        return new MessageListener() {
            public void onMessage(Message message) {
                System.out.println("received: " + message);
            }
        };
    }
}]]></programlisting></sect2>
  </section>

  <section>
    <title>Message Converters</title>

    <para>The <interfacename>AmqpTemplate</interfacename> also defines several
    methods for sending and receiving Messages that will delegate to a
    <interfacename>MessageConverter</interfacename>. The
    <interfacename>MessageConverter</interfacename> itself is quite
    straightforward. It provides a single method for each direction: one for
    converting <emphasis>to</emphasis> a Message and another for converting
    <emphasis>from</emphasis> a Message. Notice that when converting to a
    Message, you may also provide properties in addition to the object. The
    "object" parameter typically corresponds to the Message body.</para>

    <programlisting language="java"><![CDATA[public interface MessageConverter {

    Message toMessage(Object object, MessageProperties messageProperties)
            throws MessageConversionException;

    Object fromMessage(Message message) throws MessageConversionException;

}]]></programlisting>

    <para>The relevant Message-sending methods on the
    <interfacename>AmqpTemplate</interfacename> are listed below. They
    are simpler than the methods we discussed previously because they
    do not require the <classname>Message</classname> instance.
    Instead, the <interfacename>MessageConverter</interfacename> is
    responsible for "creating" each <classname>Message</classname> by
    converting the provided object to the byte array for
    the <classname>Message</classname> body and then adding any
    provided <classname>MessageProperties</classname>.</para>

    <programlisting language="java"><![CDATA[void convertAndSend(Object message) throws AmqpException;

void convertAndSend(String routingKey, Object message) throws AmqpException;

void convertAndSend(String exchange, String routingKey, Object message) throws AmqpException;

void convertAndSend(Object message, MessagePostProcessor messagePostProcessor) throws AmqpException;

void convertAndSend(String routingKey, Object message, MessagePostProcessor messagePostProcessor)
        throws AmqpException;

void convertAndSend(String exchange, String routingKey, Object message,
        MessagePostProcessor messagePostProcessor) throws AmqpException;]]></programlisting>

    <para>On the receiving side, there are only two methods: one that accepts
    the queue name and one that relies on the template's "queue" property
    having been set.</para>

    <programlisting language="java"><![CDATA[Object receiveAndConvert() throws AmqpException;

Object receiveAndConvert(String queueName) throws AmqpException;]]></programlisting>

    <sect2>
      <title>SimpleMessageConverter</title>

      <para>The default implementation of the
      <interfacename>MessageConverter</interfacename> strategy is called
      <classname>SimpleMessageConverter</classname>. This is the converter
      that will be used by an instance of RabbitTemplate if you do not
      explicitly configure an alternative. It handles text-based content,
      serialized Java objects, and simple byte arrays.</para>

      <sect3>
        <title>Converting From a Message</title>

        <para>If the content type of the input Message begins with "text"
        (e.g. "text/plain"), it will also check for the content-encoding
        property to determine the charset to be used when converting the
        Message body byte array to a Java String. If no content-encoding
        property had been set on the input Message, it will use the "UTF-8"
        charset by default. If you need to override that default setting, you
        can configure an instance of
        <classname>SimpleMessageConverter</classname>, set its
        "defaultCharset" property and then inject that into a
        <classname>RabbitTemplate</classname> instance.</para>

        <para>If the content-type property value of the input Message is set
        to "application/x-java-serialized-object", the
        <classname>SimpleMessageConverter</classname> will attempt to
        deserialize (rehydrate) the byte array into a Java object. While that
        might be useful for simple prototyping, it's generally not recommended
        to rely on Java serialization since it leads to tight coupling between
        the producer and consumer. Of course, it also rules out usage of
        non-Java systems on either side. With AMQP being a wire-level
        protocol, it would be unfortunate to lose much of that advantage with
        such restrictions. In the next two sections, we'll explore some
        alternatives for passing rich domain object content without relying on
        Java serialization.</para>

        <para>For all other content-types, the
        <classname>SimpleMessageConverter</classname> will return the Message
        body content directly as a byte array.</para>
      </sect3>

      <sect3>
        <title>Converting To a Message</title>

        <para>When converting to a Message from an arbitrary Java Object, the
        <classname>SimpleMessageConverter</classname> likewise deals with byte
        arrays, Strings, and Serializable instances. It will convert each of
        these to bytes (in the case of byte arrays, there is nothing to
        convert), and it will set the content-type property accordingly. If
        the Object to be converted does not match one of those types, the
        Message body will be null.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>JsonMessageConverter</title>

      <para>As mentioned in the previous section, relying on Java
      serialization is generally not recommended. One rather common
      alternative that is more flexible and portable across different
      languages and platforms is JSON (JavaScript Object Notation). An
      implementation is available and can be configured on any
      <classname>RabbitTemplate</classname> instance to override its usage of
      the <classname>SimpleMessageConverter</classname> default.</para>

      <programlisting language="xml"><![CDATA[<bean class="org.springframework.amqp.rabbit.core.RabbitTemplate">
    <property name="connectionFactory" ref="rabbitConnectionFactory"/>
    <property name="messageConverter">
        <bean class="org.springframework.amqp.support.converter.JsonMessageConverter">
            <!-- if necessary, override the DefaultClassMapper -->
            <property name="classMapper" ref="customClassMapper"/>
        </bean>
    </property>
</bean>]]></programlisting>
    </sect2>

    <sect2>
      <title>MarshallingMessageConverter</title>

      <para>Yet another option is the
      <classname>MarshallingMessageConverter</classname>. It delegates to the
      Spring OXM library's implementations of the
      <interfacename>Marshaller</interfacename> and
      <interfacename>Unmarshaller</interfacename> strategy interfaces. You can
      read more about that library <ulink
      url="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/oxm.html">here</ulink>.
      In terms of configuration, it's most common to provide the constructor
      argument only since most implementations of
      <interfacename>Marshaller</interfacename> will also implement
      <interfacename>Unmarshaller</interfacename>.</para>

      <programlisting language="xml"><![CDATA[<bean class="org.springframework.amqp.rabbit.core.RabbitTemplate">
    <property name="connectionFactory" ref="rabbitConnectionFactory"/>
    <property name="messageConverter">
        <bean class="org.springframework.amqp.support.converter.MarshallingMessageConverter">
            <constructor-arg ref="someImplemenationOfMarshallerAndUnmarshaller"/>
        </bean>
    </property>
</bean>]]></programlisting>
    </sect2>
  </section>

  <section id="request-reply">
    <title>Request/Reply Messaging</title>

    <para>The <classname>AmqpTemplate</classname> also provides a variety of
    <methodname>sendAndReceive</methodname> methods that accept the same argument options
    that you have seen above for the one-way send operations (exchange, routingKey, and Message).
    Those methods are quite useful for request/reply scenarios since they handle the configuration
    of the necessary "reply-to" property before sending and can listen for the reply message on an
    exclusive Queue that is created internally for that purpose.</para>

    <para>Similar request/reply methods are also available where the <classname>MessageConverter</classname>
    is applied to both the request and reply. Those methods are named <methodname>convertSendAndReceive</methodname>.
    See the Javadoc of <classname>AmqpTemplate</classname> for more detail.</para>
    <para>
    By default, a new temporary queue is used for each reply. However, a single reply queue can be configured on the template,
    which allows you to set arguments on that queue (such as 'ha_args="all"' for mirrored queues). In this case, however, 
    you must also provide a &lt;reply-listener/&gt; sub element. This element provides a listener container for the
    reply queue, with the template being the listener. All of the <xref linkend="containerAttributes" /> attributes
    allowed on a &lt;listener-container/&gt; are allowed on the element, except for connection-factory and
    message-converter, which are inherited from the template's configuration.
    <programlisting language="xml"><![CDATA[<rabbit:template id="amqpTemplate"
        connection-factory="connectionFactory" reply-queue="replies">
    <rabbit:reply-listener />
</rabbit:template>
]]></programlisting>
    </para>
    <para>
    While the container and template share a connection factory, they do not share a channel and therefore requests
    and replies are not performed within the same transaction (if transactional).
    </para>
  </section>

  <section id="broker-configuration">
    <title>Configuring the broker</title>

    <para>The AMQP specification describes how the protocol can be used to
    configure Queues, Exchanges and Bindings on the broker. These operations
    which are portable from the 0.8 specification and higher are present in
    the AmqpAdmin interface in the org.springframework.amqp.core package. The
    RabbitMQ implementation of that class is RabbitAdmin located in the
    org.springframework.amqp.rabbit.core package.</para>

    <para>The AmqpAdmin interface is based on using the Spring AMQP domain
    abstractions and is shown below:</para>

    <programlisting language="java"><![CDATA[public interface AmqpAdmin {

    // Exchange Operations

    void declareExchange(Exchange exchange);

    void deleteExchange(String exchangeName);

    // Queue Operations

    Queue declareQueue();

    void declareQueue(Queue queue);

    void deleteQueue(String queueName);

    void deleteQueue(String queueName, boolean unused, boolean empty);

    void purgeQueue(String queueName, boolean noWait);

    // Binding Operations

    void declareBinding(Binding binding);

}]]></programlisting>

    <para>The no-arg declareQueue() method defines a queue on the broker whose name
    is automatically generated. The additional properties of this auto-generated
    queue are exclusive=true, autoDelete=true, and durable=false.<note>
        <para>Removing a binding was not introduced until the 0.9 version of
        the AMQP spec.</para>
      </note></para>

    <para>The RabbitMQ implementation of this interface is RabbitAdmin which
    when configured using Spring XML would look like this:<programlisting
    language="xml"><![CDATA[<rabbit:connection-factory id="connectionFactory"/>

<rabbit:admin id="amqpAdmin" connection-factory="connectionFactory"/>]]></programlisting></para>

    <para>The <classname>RabbitAdmin</classname> implementation does automatic
    lazy declaration of <classname>Queues</classname>,
    <classname>Exchanges</classname> and <classname>Bindings</classname>
    declared in the same <classname>ApplicationContext</classname>. These
    components will be declared as son as a <classname>Connection</classname>
    is opened to the broker. There are some namespace features that make this
    very convenient, e.g. in the Stocks sample application we have:</para>

    <programlisting><![CDATA[<rabbit:queue id="tradeQueue" />

<rabbit:queue id="marketDataQueue" />

<fanout-exchange name="broadcast.responses" xmlns="http://www.springframework.org/schema/rabbit">
  <bindings>
    <binding queue="tradeQueue" />
  </bindings>
</fanout-exchange>

<topic-exchange name="app.stock.marketdata" xmlns="http://www.springframework.org/schema/rabbit">
  <bindings>
    <binding queue="marketDataQueue" pattern="${stocks.quote.pattern}" />
  </bindings>
</topic-exchange>]]></programlisting>

    <para>In the example above we are using anonymous Queues (actually
    internally just Queues with names generated by the framework, not by the
    broker) and refer to them by ID. We can also declare Queues with explicit
    names, which also serve as identifiers for their bean definitions in the
    context. E.g.</para>

    <programlisting><![CDATA[<rabbit:queue name="stocks.trade.queue"/>]]></programlisting>

    <para>To see how to use Java to configure the AMQP infrastructure, look at
    the Stock sample application, where there is the <code>@Configuration</code>
    class <classname>AbstractStockRabbitConfiguration</classname> which in
    turn has RabbitClientConfiguration and RabbitServerConfiguration
    subclasses. The code for AbstractStockRabbitConfiguration is shown
    below</para>

    <programlisting language="java"><![CDATA[@Configuration
public abstract class AbstractStockAppRabbitConfiguration {

    @Bean
    public ConnectionFactory connectionFactory() {
        CachingConnectionFactory connectionFactory = new CachingConnectionFactory("localhost");
        connectionFactory.setUsername("guest");
        connectionFactory.setPassword("guest");
        return connectionFactory;
    }

    @Bean
    public RabbitTemplate rabbitTemplate() {
        RabbitTemplate template = new RabbitTemplate(connectionFactory());
        template.setMessageConverter(jsonMessageConverter());
        configureRabbitTemplate(template);
        return template;
    }

    @Bean
    public MessageConverter jsonMessageConverter() {
        return new JsonMessageConverter();
    }

    @Bean
    public TopicExchange marketDataExchange() {
        return new TopicExchange("app.stock.marketdata");
    }

    // additional code omitted for brevity

}]]></programlisting>

    <para>In the Stock application, the server is configured using the
    following @Configuration class:</para>

    <programlisting language="java"><![CDATA[@Configuration
public class RabbitServerConfiguration extends AbstractStockAppRabbitConfiguration  {

    @Bean
    public Queue stockRequestQueue() {
        return new Queue("app.stock.request");
    }
}]]></programlisting>

    <para>This is the end of the whole inheritance chain of @Configuration
    classes. The end result is the the TopicExchange and Queue will be
    declared to the broker upon application startup. There is no binding of
    the TopicExchange to a queue in the server configuration, as that is done
    in the client application. The stock request queue however is
    automatically bound to the AMQP default exchange - this behavior is
    defined by the specification.</para>

    <para>The client @Configuration class is a little more interesting and is
    shown below.</para>

    <programlisting language="java"><![CDATA[@Configuration
public class RabbitClientConfiguration extends AbstractStockAppRabbitConfiguration {

    @Value("${stocks.quote.pattern}")
    private String marketDataRoutingKey;

    @Bean
    public Queue marketDataQueue() {
        return amqpAdmin().declareQueue();
    }

    /**
     * Binds to the market data exchange. Interested in any stock quotes
     * that match its routing key.
     */
    @Bean
    public Binding marketDataBinding() {
        return BindingBuilder.bind(
                marketDataQueue()).to(marketDataExchange()).with(marketDataRoutingKey);
    }

    // additional code omitted for brevity

}]]></programlisting>

    <para>The client is declaring another queue via the declareQueue() method
    on the AmqpAdmin, and it binds that queue to the market data exchange with
    a routing pattern that is externalized in a properties file.</para>
  </section>

  <section>
    <title>Exception Handling</title>

    <para>Many operations with the RabbitMQ Java client can throw checked
    Exceptions. For example, there are a lot of cases where IOExceptions may
    be thrown. The RabbitTemplate, SimpleMessageListenerContainer, and other
    Spring AMQP components will catch those Exceptions and convert into one of
    the Exceptions within our runtime hierarchy. Those are defined in the
    'org.springframework.amqp' package, and AmqpException is the base of the
    hierarchy.</para>

    <para>If you are using a
    <classname>SimpleMessageListenerContainer</classname> you will also be
    able to inject a Spring <classname>ErrorHandler</classname> instance that
    can be used to react to an exception in the listener. The
    <classname>ErrorHandler</classname> cannot prevent the exception from
    eventually propagating, but it can be used to log or alert another
    component that there is a problem.</para>
  </section>

  <section>
    <title>Transactions</title>

    <para>The Spring Rabbit framework has support for automatic transaction
    management in the synchronous and asynchronous use cases with a number of
    different semantics that can be selected declaratively, as is familiar to
    existing users of Spring transactions. This makes many if not most common
    messaging patterns very easy to implement.</para>

    <para>There are two ways to signal the desired transaction semantics to
    the framework. In both the <classname>RabbitTemplate</classname> and
    <classname>SimpleMessageListenerContainer</classname> there is a flag
    <code>channelTransacted</code> which, if true, tells the framework to use
    a transactional channel and to end all operations (send or receive) with a
    commit or rollback depending on the outcome, with an exception signaling
    a rollback. Another signal is to provide an external transaction with one
    of Spring's <classname>PlatformTransactionManager</classname>
    implementations as a context for the ongoing operation. If there is
    already a transaction in progress when the framework is sending or
    receiving a message, and the <code>channelTransacted</code> flag is true,
    then the commit or rollback of the messaging transaction will be deferred
    until the end of the current transaction. If the
    <code>channelTransacted</code> flag is false, then no transaction
    semantics apply to the messaging operation (it is auto-acked).</para>

    <para>The <classname>channelTransacted</classname> flag is a configuration
    time setting: it is declared and processed once when the AMQP components
    are created, usually at application startup. The external transaction is
    more dynamic in principle because the system responds to the current
    Thread state at runtime, but in practice is often also a configuration
    setting, when the transactions are layered onto an application
    declaratively.</para>

    <para>For synchronous use cases with <classname>RabbitTemplate</classname>
    the external transaction is provided by the caller, either declaratively
    or imperatively according to taste (the usual Spring transaction model).
    An example of a declarative approach (usually preferred because it is
    non-invasive), where the template has been configured with
    <code>channelTransacted=true</code>:</para>

    <programlisting><![CDATA[@Transactional
public void doSomething() {
    String incoming = rabbitTemplate.receiveAndConvert();
    // do some more database processing...
    String outgoing = processInDatabaseAndExtractReply(incoming);
    rabbitTemplate.convertAndSend(outgoing);
}]]></programlisting>

    <para>A String payload is received, converted and sent as a message body
    inside a method marked as @Transactional, so if the database processing
    fails with an exception, the incoming message will be returned to the
    broker, and the outgoing message will not be sent. This applies to any
    operations with the <classname>RabbitTemplate</classname> inside a chain
    of transactional methods (unless the <classname>Channel</classname> is
    directly manipulated to commit the transaction early for instance).</para>

    <para>For asynchronous use cases with
    <classname>SimpleMessageListenerContainer</classname> if an external
    transaction is needed it has to be requested by the container when it sets
    up the listener. To signal that an external transaction is required the
    user provides an implementation of
    <classname>PlatformTransactionManager</classname> to the container when it
    is configured. For example:</para>

    <programlisting><![CDATA[@Configuration
public class ExampleExternalTransactionAmqpConfiguration {

    @Bean
    public MessageListenerContainer messageListenerContainer() {
        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
        container.setConnectionFactory(rabbitConnectionFactory());
        container.setTransactionManager(transactionManager());
        container.setChannelTransacted(true);
        container.setQueueName("some.queue");
        container.setMessageListener(exampleListener());
        return container;
    }

}]]></programlisting>

    <para>In the example above, the transaction manager is added as a
    dependency injected from another bean definition (not shown), and the
    <code>channelTransacted</code> flag is also set to true. The effect is
    that if the listener fails with an exception the transaction will be
    rolled back, and the message will also be returned to the broker.
    Significantly, if the transaction fails to commit (e.g. a database
    constraint error, or connectivity problem), then the AMQP transaction will
    also be rolled back, and the message will be returned to the broker. This is
    sometimes known as a Best Efforts 1 Phase Commit, and is a very powerful
    pattern for reliable messaging. If the <code>channelTransacted</code> flag
    was set to false in the example above, which is the default, then the
    external transaction would still be provided for the listener, but all
    messaging operations would be auto-acked, so the effect is to commit the
    messaging operations even on a rollback of the business operation.</para>

    <section>
      <title>A note on Rollback of Received Messages</title>

      <para>AMQP transactions only apply to messages and acks sent to the
      broker, so when there is a rollback of a Spring transaction and a
      message has been received, what Spring AMQP has to do is not just
      rollback the transaction, but also manually reject the message (sort of
      a nack, but that's not what the specification calls it). Such messages
      (and any that are unacked when a channel is closed or aborts) go to the
      back of the queue on a Rabbit broker, and this behaviour is not what
      some users expect, especially if they come from a JMS background, so
      it's good to be aware of it. The re-queuing order is not mandated by the
      AMQP specification, but it makes the broker much more efficient, and
      also means that if it is under load there is a natural back off before
      the message can be consumed again.</para>
    </section>
  </section>

  <section id="containerAttributes">
    <title>Message Listener Container Configuration</title>

    <para>There are quite a few options for configuring a
    <classname>SimpleMessageListenerContainer</classname> related to
    transactions and quality of service, and some of them interact with each
    other.</para>

    <para>When configuring with the XML namespace, the convention is to
    use hyphenated attributes rather than camel case; for example, for
    property 'connectionFactory', the XML equivalent is 'connection-factory'.</para>

    <para><table>
        <title>Configuration options for a message listener container</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Property</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>channelTransacted</entry>

              <entry>Boolean flag to signal that all messages should be
              acknowledged in a transaction (either manually or
              automatically)</entry>
            </row>

            <row>
              <entry>acknowledgeMode</entry>

              <entry><literal>NONE</literal> = no acks will be sent (the
              default and incompatible with
              <literal>channelTransacted=true</literal>). RabbitMQ calls this
              "autoack" because the broker assumes all messages are acked
              without any action from the consumer. MANUAL = the listener must
              acknowledge all messages by calling
              <code>Channel.basicAck()</code>. AUTO = the container will
              acknowledge the message automatically. Note that
              <literal>acknowledgeMode</literal> is complementary to
              channelTransacted - if the channel is transacted then the broker
              requires a commit notification in addition to the ack.</entry>
            </row>

            <row>
              <entry>transactionManager</entry>

              <entry>External transaction manager for the operation of the
              listener. Also complementary to channelTransacted - if the
              <classname>Channel</classname> is transacted then its
              transaction will be synchronized with the external
              transaction.</entry>
            </row>

            <row>
              <entry>prefetchCount</entry>

              <entry>The number of messages to accept from the broker in one
              socket frame. The higher this is the faster the messages can be
              delivered, but the higher the risk of non-sequential processing.
              Ignored if the <literal>acknowledgeMode</literal> is
              NONE.</entry>
            </row>

            <row>
              <entry>shutdownTimeout</entry>

              <entry>When a container shuts down (e.g. if its enclosing
              <classname>ApplicationContext</classname> is closed) it waits
              for in-flight messages to be processed up to this limit.
              Defaults to 10 seconds. After the limit is reached, if the
              channel is not transacted messages will be discarded.</entry>
            </row>

            <row>
              <entry>txSize</entry>

              <entry>If the channel is transacted or an external transaction
              manager is provided, the container will attempt to process up to
              this number of messages per transaction (waiting for each one up
              to the receive timeout setting).</entry>
            </row>

            <row>
              <entry>receiveTimeout</entry>

              <entry>The maximum time to wait for each message. If
              acknowledgeMode=NONE (the default) this has very little effect -
              the container just spins round and asks for another message. It
              has the biggest effect for a transactional
              <classname>Channel</classname> with <code>txSize &gt; 1</code>,
              since it can cause messages already consumed not to be
              acknowledged until the timeout expires.</entry>
            </row>

            <row>
              <entry>autoStartup</entry>

              <entry>Flag to indicate that the container should start when the
              <classname>ApplicationContext</classname> does (as part of the
              <classname>SmartLifecycle</classname> callbacks which happen
              after all beans are initialized). Defaults to true, but set it
              to false if your broker might not be available on startup, and
              then call <code>start()</code> later manually when you know the
              broker is ready.</entry>
            </row>

            <row>
              <entry>phase</entry>

              <entry>When autoStartup is true, the lifecycle phase within
              which this container should start and stop. The lower the
              value the earlier this container will start and the later it
              will stop. The default is Integer.MAX_VALUE meaning the
              container will start as late as possible and stop as
              soon as possible.</entry>
            </row>

            <row>
              <entry>adviceChain</entry>

              <entry>An array of AOP Advice to apply to the listener
              execution. This can be used to apply additional cross cutting
              concerns such as automatic retry in the event of broker death.
              Note that simple re-connection after an AMQP error is handled by
              the <classname>CachingConnectionFactory</classname>, as long as
              the broker is still alive.</entry>
            </row>

            <row>
              <entry>taskExecutor</entry>
              
              <entry>A reference to a Spring TaskExecutor (or standard JDK 1.5+
              Executor) for executing listener invokers. Default is a
              SimpleAsyncTaskExecutor, using internally managed threads.</entry>
            </row>

            <row>
              <entry>errorHandler</entry>
              
              <entry>A reference to an ErrorHandler strategy for handling any
              uncaught Exceptions that may occur during the execution of the
              MessageListener.</entry>
            </row>

            <row>
              <entry>concurrency</entry>
              
              <entry>The number of concurrent consumers to start for each
              listener.</entry>
            </row>

            <row>
              <entry>connectionFactory</entry>
              
              <entry>A reference to the connectionFactory; when configuring
              using the XML namespace, the default referenced bean name
              is "rabbitConnectionFactory".</entry>
            </row>

            <row>
              <entry>messageConverter</entry>
              
              <entry>A reference to the MessageConverter strategy for
              converting AMQP Messages to listener method arguments
              for any referenced 'listener' that is a POJO. Default is
              a SimpleMessageConverter.</entry>
            </row>
          </tbody>
        </tgroup>
      </table></para>
  </section>

  <section>
    <title>Resilience: Recovering from Errors and Broker Failures</title>

    <para>Some of the key (and most popular) high-level features that
    Spring AMQP provides are to do with recovery and automatic
    re-connection in the event of a protocol error or broker failure.
    We have seen all the relevant components already in this guide,
    but it should help to bring them all together here and call out
    the features and recovery scenarios individually.</para>

    <para>The primary reconnection features are enabled by the
    <classname>CachingConnectionFactory</classname> itself. 
    It is also often beneficial to use the <classname>RabbitAdmin</classname>
    auto-declaration features. In addition, if you care about
    guaranteed delivery, you probably also need to use the
    <code>channelTransacted</code> flag in
    <classname>RabbitTemplate</classname> and
    <classname>SimpleMessageListenerContainer</classname> and also the
    <code>AcknowledgeMode.AUTO</code> (or manual if you do the acks
    yourself) in the
    <classname>SimpleMessageListenerContainer</classname>.</para>

    <section>
      <title>Automatic Declaration of Exchanges, Queues and
      Bindings</title>

      <para>The <classname>RabbitAdmin</classname> component can
      declare exchanges, queues and bindings on startup.  It does this
      lazily, through a <classname>ConnectionListener</classname>, so
      if the broker is not present on startup it doesn't matter.  The
      first time a <classname>Connection</classname> is used (e.g. by
      sending a message) the listener will fire and the admin features
      will be applied.  A further benefit of doing the auto
      declarations in a listener is that if the connection is dropped
      for any reason (e.g. broker death, network glitch, etc.) they
      will be applied again the next time they are needed.</para>

    </section>

    <section>
      <title>Failures in Synchronous Operations and Options for Retry</title>

      <para>If you lose your connection to the broker in a synchronous
      sequence using <classname>RabbitTemplate</classname> (for
      instance), then Spring AMQP will throw an
      <classname>AmqpException</classname> (usually but not always
      <classname>AmqpIOException</classname>).  We don't try to hide
      the fact that there was a problem, so you have to be able to
      catch and respond to the exception.  The easiest thing to do if
      you suspect that the connection was lost, and it wasn't your
      fault, is to simply try the operation again.  You can do this
      manually, or you could look at using Spring Retry to handle the
      retry (imperatively or declaratively).</para>

      <para>Spring Retry provides a couple of AOP interceptors and a
      great deal of flexibility to specify the parameters of the retry
      (number of attempts, exception types, backoff algorithm etc.).
      Spring AMQP also provides some convenience factory beans for
      creating Spring Retry interceptors in a convenient form for AMQP
      use cases, with strongly typed callback interfaces for you to
      implement custom recovery logic.  See the Javadocs and
      properties of
      <classname>StatefulRetryOperationsInterceptor</classname> and
      <classname>StatelessRetryOperationsInterceptor</classname> for
      more detail.  Stateless retry is appropriate if there is no
      transaction or if a transaction is started inside the retry
      callback.  Note that stateless retry is simpler to configure and
      analyse than stateful retry, but it is not usually appropriate
      if there is an ongoing transaction which must be rolled back or
      definitely is going to roll back.  A dropped connection in the
      middle of a transaction should have the same effect as a
      rollback, so for reconnection where the transaction is started
      higher up the stack, stateful retry is usually the best
      choice.</para>

    </section>

    <section>
      <title>Message Listeners and the Asynchronous Case</title>

      <para>If a <classname>MessageListener</classname> fails because
      of a business exception, the exception is handled by the message
      listener container and then it goes back to listening for
      another message.  If the failure is caused by a dropped
      connection (not a business exception), then the consumer that is
      collecting messages for the listener has to be cancelled and
      restarted.  The
      <classname>SimpleMessageListenerContainer</classname> handles
      this seamlessly, and it leaves a log to say that the listener is
      being restarted.  In fact it loops endlessly trying to restart
      the consumer, and only if the consumer is very badly behaved
      indeed will it give up.  One side effect is that if the broker
      is down when the container starts, it will just keep trying
      until a connection can be established.</para>

      <para>Business exception handling, as opposed to protocol errors
      and dropped connections, might need more thought and some custom
      configuration, especially if transactions and/or container acks
      are in use.  AMQP has no definition of dead letter behaviour, so
      by default a message that is rejected or rolled back because of
      a business exception can be redelivered ad infinitum.  To put a
      limit in the client on the number of re-deliveries your best
      choice is a
      <classname>StatefulRetryOperationsInterceptor</classname> in the
      advice chain of the listener.  The interceptor can have a
      recovery callback that implements a custom dead letter action:
      whatever is appropriate for your particular environment.</para>

    </section>

  </section>

</chapter>
